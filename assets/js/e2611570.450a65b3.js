"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[154],{1473(e,n,t){t.d(n,{A:()=>h});t(6540);var r=t(4164);const s="container_DYDm",i="header_yOrC",a="titleSection_jiBk",o="icon_OiJW",l="title_bD_B",c="meta_N7Me",d="time_Cevp",m="difficulty_aRrW",p="content_CCam";var f=t(4848);const h=({title:e,time:n,difficulty:t,children:h})=>(0,f.jsxs)("div",{className:(0,r.A)("lab-activity-container",s),children:[(0,f.jsxs)("div",{className:i,children:[(0,f.jsxs)("div",{className:a,children:[(0,f.jsx)("span",{className:o,children:"\ud83e\uddea"}),(0,f.jsx)("h3",{className:l,children:e||"Lab Activity"})]}),(0,f.jsxs)("div",{className:c,children:[n&&(0,f.jsxs)("span",{className:d,children:["\u23f1\ufe0f ",n]}),t&&(0,f.jsxs)("span",{className:m,children:["\ud83c\udfaf ",t]})]})]}),(0,f.jsx)("div",{className:p,children:h})]})},2974(e,n,t){t.r(n),t.d(n,{assets:()=>f,contentTitle:()=>m,default:()=>u,frontMatter:()=>d,metadata:()=>p,toc:()=>h});var r=t(4848),s=t(8453),i=t(8415),a=t(1473),o=t(3466),l=t(7944),c=t(6274);const d={sidebar_position:6},m="Chapter 5: TF and Navigation Fundamentals",p={id:"module-1/chapter-5",title:"Chapter 5: TF and Navigation Fundamentals",description:"Chapter Purpose",source:"@site/docs/module-1/chapter-5.md",sourceDirName:"module-1",slug:"/module-1/chapter-5",permalink:"/hackathon_project1/docs/module-1/chapter-5",draft:!1,unlisted:!1,editUrl:"https://github.com/physical-ai-robotics-book/physical-ai-robotics-book/tree/main/docusaurus/docs/module-1/chapter-5.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"textbookSidebar",previous:{title:"Chapter 4: Parameters and Launch Systems",permalink:"/hackathon_project1/docs/module-1/chapter-4"},next:{title:"Chapter 6: Real-world Integration and Best Practices",permalink:"/hackathon_project1/docs/module-1/chapter-6"}},f={},h=[{value:"Chapter Purpose",id:"chapter-purpose",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Practical Demonstrations",id:"practical-demonstrations",level:2},{value:"1. Creating TF Broadcasters for Robot Links",id:"1-creating-tf-broadcasters-for-robot-links",level:3},{value:"2. Visualizing TF Tree with rviz2",id:"2-visualizing-tf-tree-with-rviz2",level:3},{value:"3. Transform Lookup and Point Transformations",id:"3-transform-lookup-and-point-transformations",level:3},{value:"Hands-on Coding Labs",id:"hands-on-coding-labs",level:2},{value:"Objective",id:"objective",level:3},{value:"Steps",id:"steps",level:3},{value:"Expected Outcome",id:"expected-outcome",level:3},{value:"Troubleshooting Tips",id:"troubleshooting-tips",level:3},{value:"Objective",id:"objective-1",level:3},{value:"Steps",id:"steps-1",level:3},{value:"Expected Outcome",id:"expected-outcome-1",level:3},{value:"Troubleshooting Tips",id:"troubleshooting-tips-1",level:3},{value:"Objective",id:"objective-2",level:3},{value:"Steps",id:"steps-2",level:3},{value:"Expected Outcome",id:"expected-outcome-2",level:3},{value:"Troubleshooting Tips",id:"troubleshooting-tips-2",level:3},{value:"ROS 2 Packages/Tools Used",id:"ros-2-packagestools-used",level:2},{value:"Simulation vs Real-Robot Activities",id:"simulation-vs-real-robot-activities",level:2},{value:"Simulation:",id:"simulation",level:3},{value:"Real Robot:",id:"real-robot",level:3},{value:"Diagrams and Figures",id:"diagrams-and-figures",level:2},{value:"TF Tree Visualization Example",id:"tf-tree-visualization-example",level:3},{value:"Coordinate Frame Transformation Mathematics",id:"coordinate-frame-transformation-mathematics",level:3},{value:"URDF to TF Relationship Diagram",id:"urdf-to-tf-relationship-diagram",level:3},{value:"Checklists",id:"checklists",level:2},{value:"\u2713 TF Tree Validation Checklist",id:"-tf-tree-validation-checklist",level:3},{value:"\u2713 URDF Model Correctness Checklist",id:"-urdf-model-correctness-checklist",level:3},{value:"\u2713 Transform Lookup Accuracy Checklist",id:"-transform-lookup-accuracy-checklist",level:3},{value:"Glossary Terms",id:"glossary-terms",level:2},{value:"Cross-References",id:"cross-references",level:2},{value:"Optional Advanced Section",id:"optional-advanced-section",level:2},{value:"TF Interpolation and Buffering Strategies",id:"tf-interpolation-and-buffering-strategies",level:3},{value:"Multi-robot TF Management",id:"multi-robot-tf-management",level:3},{value:"Assignment Tasks",id:"assignment-tasks",level:3},{value:"Submission Requirements",id:"submission-requirements",level:3},{value:"References",id:"references",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"chapter-5-tf-and-navigation-fundamentals",children:"Chapter 5: TF and Navigation Fundamentals"}),"\n","\n","\n",(0,r.jsx)(n.h2,{id:"chapter-purpose",children:"Chapter Purpose"}),"\n",(0,r.jsx)(n.p,{children:"This chapter covers coordinate frame management and spatial relationships essential for robot navigation. Students will learn to create TF broadcasters for robot links, visualize TF trees with rviz2, perform transform lookups between coordinate frames, and understand how TF integrates with navigation systems. The chapter emphasizes practical application of TF in robotic perception and motion planning."}),"\n",(0,r.jsx)(i.A,{objectives:["Create TF broadcasters for robot state and coordinate frame management","Visualize TF trees with rviz2 for debugging and analysis","Perform transform lookups and point transformations between frames","Integrate TF with navigation stack for spatial reasoning","Build URDF models with proper TF frame definitions"]}),"\n",(0,r.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transform (TF) tree and coordinate frame management"}),": Understanding the hierarchical structure of coordinate frames"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Static and dynamic transforms"}),": Distinguishing between fixed and changing coordinate relationships"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Coordinate frame conversions and transformations"}),": Converting points between different coordinate systems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Basic navigation stack integration"}),": Using TF for spatial reasoning in navigation systems"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"practical-demonstrations",children:"Practical Demonstrations"}),"\n",(0,r.jsx)(n.h3,{id:"1-creating-tf-broadcasters-for-robot-links",children:"1. Creating TF Broadcasters for Robot Links"}),"\n",(0,r.jsx)(n.p,{children:"Creating a broadcaster for a simple robot with multiple links:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# tf_broadcaster.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import TransformStamped\nfrom tf2_ros import TransformBroadcaster\nimport math\n\nclass StaticFramePublisher(Node):\n    def __init__(self):\n        super().__init__('static_frame_publisher')\n        self.tf_broadcaster = TransformBroadcaster(self)\n\n        # Define static transforms for robot\n        self.base_to_laser = TransformStamped()\n        self.base_to_laser.header.frame_id = 'base_link'\n        self.base_to_laser.child_frame_id = 'laser_frame'\n        self.base_to_laser.transform.translation.x = 0.1  # 10cm forward\n        self.base_to_laser.transform.translation.y = 0.0\n        self.base_to_laser.transform.translation.z = 0.2  # 20cm up\n        # No rotation - identity quaternion\n        self.base_to_laser.transform.rotation.x = 0.0\n        self.base_to_laser.transform.rotation.y = 0.0\n        self.base_to_laser.transform.rotation.z = 0.0\n        self.base_to_laser.transform.rotation.w = 1.0\n\n    def publish_static_transforms(self):\n        # Publish static transforms\n        self.base_to_laser.header.stamp = self.get_clock().now().to_msg()\n        self.tf_broadcaster.sendTransform(self.base_to_laser)\n\nclass DynamicFramePublisher(Node):\n    def __init__(self):\n        super().__init__('dynamic_frame_publisher')\n        self.tf_broadcaster = TransformBroadcaster(self)\n        self.timer = self.create_timer(0.1, self.broadcast_tf)  # 10 Hz\n        self.theta = 0.0\n\n    def broadcast_tf(self):\n        t = TransformStamped()\n\n        # Define coordinate frames\n        t.header.stamp = self.get_clock().now().to_msg()\n        t.header.frame_id = 'base_link'\n        t.child_frame_id = 'rotating_frame'\n\n        # Set translation\n        t.transform.translation.x = 0.5 * math.cos(self.theta)\n        t.transform.translation.y = 0.5 * math.sin(self.theta)\n        t.transform.translation.z = 0.0\n\n        # Set rotation (rotate around Z axis)\n        t.transform.rotation.x = 0.0\n        t.transform.rotation.y = 0.0\n        t.transform.rotation.z = math.sin(self.theta / 2.0)\n        t.transform.rotation.w = math.cos(self.theta / 2.0)\n\n        self.tf_broadcaster.sendTransform(t)\n        self.theta += 0.1\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    # Create both static and dynamic publishers\n    static_publisher = StaticFramePublisher()\n    dynamic_publisher = DynamicFramePublisher()\n\n    # Publish static transforms once\n    static_publisher.publish_static_transforms()\n\n    try:\n        # Run the dynamic publisher\n        rclpy.spin(dynamic_publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        dynamic_publisher.destroy_node()\n        static_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-visualizing-tf-tree-with-rviz2",children:"2. Visualizing TF Tree with rviz2"}),"\n",(0,r.jsx)(n.p,{children:"Setting up rviz2 to visualize the TF tree:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Launch rviz2 and add TF display\nros2 run rviz2 rviz2\n\n# In rviz2:\n# 1. Add by topic -> TF\n# 2. Set Fixed Frame to 'base_link' or 'map'\n# 3. Adjust visualization settings (axes size, etc.)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-transform-lookup-and-point-transformations",children:"3. Transform Lookup and Point Transformations"}),"\n",(0,r.jsx)(n.p,{children:"Performing transform lookups between frames:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# tf_lookup_client.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PointStamped\nfrom tf2_ros import TransformListener, Buffer\nfrom tf2_geometry_msgs import do_transform_point\n\nclass TFClient(Node):\n    def __init__(self):\n        super().__init__('tf_client')\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Create a timer to periodically look up transforms\n        self.timer = self.create_timer(1.0, self.lookup_transform)\n\n        # Create a publisher for transformed points\n        self.point_pub = self.create_publisher(PointStamped, 'transformed_point', 10)\n\n    def lookup_transform(self):\n        try:\n            # Look up transform from 'laser_frame' to 'base_link'\n            trans = self.tf_buffer.lookup_transform(\n                'base_link',\n                'laser_frame',\n                rclpy.time.Time(),  # Latest available\n                timeout=rclpy.duration.Duration(seconds=1.0)\n            )\n\n            self.get_logger().info(\n                f'Transform from laser_frame to base_link: '\n                f'x={trans.transform.translation.x:.3f}, '\n                f'y={trans.transform.translation.y:.3f}, '\n                f'z={trans.transform.translation.z:.3f}'\n            )\n\n            # Example: Transform a point from laser frame to base frame\n            point_in_laser = PointStamped()\n            point_in_laser.header.frame_id = 'laser_frame'\n            point_in_laser.header.stamp = self.get_clock().now().to_msg()\n            point_in_laser.point.x = 1.0  # 1m in front of laser\n            point_in_laser.point.y = 0.0\n            point_in_laser.point.z = 0.0\n\n            # Transform the point\n            point_in_base = do_transform_point(point_in_laser, trans)\n            self.get_logger().info(\n                f'Point in base_link: x={point_in_base.point.x:.3f}, '\n                f'y={point_in_base.point.y:.3f}, z={point_in_base.point.z:.3f}'\n            )\n\n            # Publish the transformed point\n            point_in_base.header.frame_id = 'base_link'\n            point_in_base.header.stamp = self.get_clock().now().to_msg()\n            self.point_pub.publish(point_in_base)\n\n        except Exception as e:\n            self.get_logger().error(f'Could not transform: {str(e)}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    tf_client = TFClient()\n\n    try:\n        rclpy.spin(tf_client)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        tf_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"hands-on-coding-labs",children:"Hands-on Coding Labs"}),"\n",(0,r.jsxs)(a.A,{title:"Lab 5.1: Building a URDF Model with TF Frames",time:"60 min",difficulty:"Hard",children:[(0,r.jsx)(n.h3,{id:"objective",children:"Objective"}),(0,r.jsx)(n.p,{children:"Create a URDF (Unified Robot Description Format) model with proper TF frame definitions for a robot."}),(0,r.jsx)(n.h3,{id:"steps",children:"Steps"}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a URDF file for a simple differential drive robot:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- ~/ros2_ws/src/robot_description/urdf/robot.urdf --\x3e\n<?xml version="1.0"?>\n<robot name="differential_drive_robot">\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.5 0.3 0.15"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 0.8"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.3 0.15"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Wheel --\x3e\n  <joint name="left_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="left_wheel"/>\n    <origin xyz="0 0.15 -0.05" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n  </joint>\n  <link name="left_wheel">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.04"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 0.8"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.04"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.1"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Right Wheel --\x3e\n  <joint name="right_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="right_wheel"/>\n    <origin xyz="0 -0.15 -0.05" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n  </joint>\n  <link name="right_wheel">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.04"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 0.8"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.04"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.1"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Laser Sensor --\x3e\n  <joint name="laser_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="laser_frame"/>\n    <origin xyz="0.2 0 0.1" rpy="0 0 0"/>\n  </joint>\n  <link name="laser_frame">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.05"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 0.8"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- IMU Sensor --\x3e\n  <joint name="imu_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="imu_frame"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n  </joint>\n  <link name="imu_frame"/>\n</robot>\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a launch file to publish the robot state:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_description/launch/robot_state.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nimport os\n\ndef generate_launch_description():\n    # Declare launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time')\n\n    # Get URDF path\n    urdf_path = os.path.join(\n        os.path.dirname(__file__),\n        '..',\n        'urdf',\n        'robot.urdf'\n    )\n\n    # Read URDF file\n    with open(urdf_path, 'r') as infp:\n        robot_desc = infp.read()\n\n    # Robot State Publisher node\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        parameters=[\n            {'use_sim_time': use_sim_time},\n            {'robot_description': robot_desc}\n        ],\n        output='screen'\n    )\n\n    # Joint State Publisher (for static joints in this case)\n    joint_state_publisher = Node(\n        package='joint_state_publisher',\n        executable='joint_state_publisher',\n        name='joint_state_publisher',\n        parameters=[\n            {'use_sim_time': use_sim_time}\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        robot_state_publisher,\n        joint_state_publisher\n    ])\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a Python script to visualize the robot in RViz:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_description/robot_description/rviz_spawner.py\nimport rclpy\nfrom rclpy.node import Node\nfrom visualization_msgs.msg import Marker\nimport math\n\nclass RvizSpawner(Node):\n    def __init__(self):\n        super().__init__('rviz_spawner')\n        self.marker_publisher = self.create_publisher(Marker, 'visualization_marker', 10)\n        self.timer = self.create_timer(1.0, self.publish_markers)\n\n    def publish_markers(self):\n        # Create a simple marker for visualization\n        marker = Marker()\n        marker.header.frame_id = \"base_link\"\n        marker.header.stamp = self.get_clock().now().to_msg()\n        marker.ns = \"robot_description\"\n        marker.id = 0\n        marker.type = Marker.CUBE\n        marker.action = Marker.ADD\n\n        # Set position and size\n        marker.pose.position.x = 0.0\n        marker.pose.position.y = 0.0\n        marker.pose.position.z = 0.0\n        marker.pose.orientation.x = 0.0\n        marker.pose.orientation.y = 0.0\n        marker.pose.orientation.z = 0.0\n        marker.pose.orientation.w = 1.0\n        marker.scale.x = 0.5\n        marker.scale.y = 0.3\n        marker.scale.z = 0.15\n        marker.color.a = 0.8  # Don't forget to set the alpha!\n        marker.color.r = 0.0\n        marker.color.g = 0.0\n        marker.color.b = 1.0\n\n        self.marker_publisher.publish(marker)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    rviz_spawner = RvizSpawner()\n\n    try:\n        rclpy.spin(rviz_spawner)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        rviz_spawner.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Build and test the URDF model:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select robot_description\nsource install/setup.bash\n\n# Launch the robot state publisher\nros2 launch robot_description robot_state.launch.py\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Visualize in RViz:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# In another terminal\nros2 run rviz2 rviz2\n# Add RobotModel display and set Robot Description to /robot_description\n# Add TF display to see the transform tree\n"})}),"\n"]}),"\n"]}),(0,r.jsx)(n.h3,{id:"expected-outcome",children:"Expected Outcome"}),(0,r.jsx)(n.p,{children:"A properly defined URDF model with coordinate frames that can be visualized in RViz and used by the TF system."}),(0,r.jsx)(n.h3,{id:"troubleshooting-tips",children:"Troubleshooting Tips"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check that all joint names and link names match between URDF and TF"}),"\n",(0,r.jsx)(n.li,{children:"Ensure URDF file is properly formatted XML"}),"\n",(0,r.jsx)(n.li,{children:"Verify that robot_state_publisher is running to publish static transforms"}),"\n"]})]}),"\n",(0,r.jsxs)(a.A,{title:"Lab 5.2: Implementing TF Broadcasters for Robot State",time:"60 min",difficulty:"Hard",children:[(0,r.jsx)(n.h3,{id:"objective-1",children:"Objective"}),(0,r.jsx)(n.p,{children:"Create TF broadcasters that publish dynamic transforms based on robot state (odometry, joint states)."}),(0,r.jsx)(n.h3,{id:"steps-1",children:"Steps"}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a TF broadcaster that publishes robot odometry transforms:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_tf/robot_tf/odometry_broadcaster.py\nimport rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Odometry\nfrom geometry_msgs.msg import TransformStamped\nfrom tf2_ros import TransformBroadcaster\nimport math\n\nclass OdometryBroadcaster(Node):\n    def __init__(self):\n        super().__init__('odometry_broadcaster')\n\n        # Initialize robot pose\n        self.x = 0.0\n        self.y = 0.0\n        self.theta = 0.0\n\n        # Create TF broadcaster\n        self.tf_broadcaster = TransformBroadcaster(self)\n\n        # Subscribe to odometry topic\n        self.subscription = self.create_subscription(\n            Odometry,\n            'odom',\n            self.odom_callback,\n            10\n        )\n        self.subscription  # prevent unused variable warning\n\n    def odom_callback(self, msg):\n        # Extract pose from odometry message\n        self.x = msg.pose.pose.position.x\n        self.y = msg.pose.pose.position.y\n\n        # Convert quaternion to yaw (simplified for 2D)\n        q = msg.pose.pose.orientation\n        siny_cosp = 2 * (q.w * q.z + q.x * q.y)\n        cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z)\n        self.theta = math.atan2(siny_cosp, cosy_cosp)\n\n        # Publish transform from odom to base_link\n        t = TransformStamped()\n        t.header.stamp = self.get_clock().now().to_msg()\n        t.header.frame_id = 'odom'\n        t.child_frame_id = 'base_link'\n\n        t.transform.translation.x = self.x\n        t.transform.translation.y = self.y\n        t.transform.translation.z = 0.0\n\n        t.transform.rotation.x = 0.0\n        t.transform.rotation.y = 0.0\n        t.transform.rotation.z = math.sin(self.theta / 2.0)\n        t.transform.rotation.w = math.cos(self.theta / 2.0)\n\n        self.tf_broadcaster.sendTransform(t)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    odometry_broadcaster = OdometryBroadcaster()\n\n    try:\n        rclpy.spin(odometry_broadcaster)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        odometry_broadcaster.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a joint state broadcaster that publishes dynamic joint transforms:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_tf/robot_tf/joint_state_broadcaster.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import TransformStamped\nfrom tf2_ros import TransformBroadcaster\nimport math\n\nclass JointStateBroadcaster(Node):\n    def __init__(self):\n        super().__init__('joint_state_broadcaster')\n\n        # Initialize joint positions\n        self.left_wheel_pos = 0.0\n        self.right_wheel_pos = 0.0\n\n        # Create TF broadcaster\n        self.tf_broadcaster = TransformBroadcaster(self)\n\n        # Subscribe to joint states\n        self.subscription = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n        self.subscription  # prevent unused variable warning\n\n    def joint_state_callback(self, msg):\n        # Update joint positions\n        for i, name in enumerate(msg.name):\n            if name == 'left_wheel_joint':\n                self.left_wheel_pos = msg.position[i]\n            elif name == 'right_wheel_joint':\n                self.right_wheel_pos = msg.position[i]\n\n        # Publish transform for left wheel\n        left_t = TransformStamped()\n        left_t.header.stamp = self.get_clock().now().to_msg()\n        left_t.header.frame_id = 'base_link'\n        left_t.child_frame_id = 'left_wheel'\n\n        left_t.transform.translation.x = 0.0\n        left_t.transform.translation.y = 0.15  # offset from base\n        left_t.transform.translation.z = -0.05  # slightly below base\n\n        # Rotate wheel based on position\n        left_t.transform.rotation.x = math.sin(self.left_wheel_pos / 2.0)\n        left_t.transform.rotation.y = 0.0\n        left_t.transform.rotation.z = 0.0\n        left_t.transform.rotation.w = math.cos(self.left_wheel_pos / 2.0)\n\n        self.tf_broadcaster.sendTransform(left_t)\n\n        # Publish transform for right wheel\n        right_t = TransformStamped()\n        right_t.header.stamp = self.get_clock().now().to_msg()\n        right_t.header.frame_id = 'base_link'\n        right_t.child_frame_id = 'right_wheel'\n\n        right_t.transform.translation.x = 0.0\n        right_t.transform.translation.y = -0.15  # offset from base\n        right_t.transform.translation.z = -0.05  # slightly below base\n\n        # Rotate wheel based on position\n        right_t.transform.rotation.x = math.sin(self.right_wheel_pos / 2.0)\n        right_t.transform.rotation.y = 0.0\n        right_t.transform.rotation.z = 0.0\n        right_t.transform.rotation.w = math.cos(self.right_wheel_pos / 2.0)\n\n        self.tf_broadcaster.sendTransform(right_t)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    joint_state_broadcaster = JointStateBroadcaster()\n\n    try:\n        rclpy.spin(joint_state_broadcaster)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        joint_state_broadcaster.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a launch file to run both broadcasters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_tf/launch/tf_broadcasters.launch.py\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='robot_tf',\n            executable='odometry_broadcaster',\n            name='odometry_broadcaster',\n            output='screen'\n        ),\n        Node(\n            package='robot_tf',\n            executable='joint_state_broadcaster',\n            name='joint_state_broadcaster',\n            output='screen'\n        )\n    ])\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Test the TF broadcasters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select robot_tf\nsource install/setup.bash\n\n# Run the broadcasters\nros2 launch robot_tf tf_broadcasters.launch.py\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Test TF transforms:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# In another terminal, check available transforms\nros2 run tf2_tools view_frames\n\n# Look up a specific transform\nros2 run tf2_ros tf2_echo odom base_link\n"})}),"\n"]}),"\n"]}),(0,r.jsx)(n.h3,{id:"expected-outcome-1",children:"Expected Outcome"}),(0,r.jsx)(n.p,{children:"TF broadcasters that publish dynamic transforms based on robot state, creating a complete transform tree that updates in real-time."}),(0,r.jsx)(n.h3,{id:"troubleshooting-tips-1",children:"Troubleshooting Tips"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensure timestamp in transforms is current"}),"\n",(0,r.jsx)(n.li,{children:"Check that frame IDs match between publishers and subscribers"}),"\n",(0,r.jsx)(n.li,{children:"Verify that the TF tree is connected from base to all frames"}),"\n"]})]}),"\n",(0,r.jsxs)(a.A,{title:"Lab 5.3: Transforming Coordinates Between Frames",time:"45 min",difficulty:"Medium",children:[(0,r.jsx)(n.h3,{id:"objective-2",children:"Objective"}),(0,r.jsx)(n.p,{children:"Implement coordinate frame transformations to convert points between different coordinate systems."}),(0,r.jsx)(n.h3,{id:"steps-2",children:"Steps"}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a transform listener and converter:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_tf/robot_tf/transform_converter.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PointStamped, Point\nfrom tf2_ros import TransformListener, Buffer\nfrom tf2_geometry_msgs import do_transform_point\nimport math\n\nclass TransformConverter(Node):\n    def __init__(self):\n        super().__init__('transform_converter')\n\n        # Create TF buffer and listener\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Create publisher for transformed points\n        self.pub = self.create_publisher(PointStamped, 'transformed_points', 10)\n\n        # Create subscription for points to transform\n        self.sub = self.create_subscription(\n            PointStamped,\n            'input_points',\n            self.transform_point,\n            10\n        )\n\n        # Timer to periodically transform a sample point\n        self.timer = self.create_timer(2.0, self.transform_sample_point)\n\n    def transform_point(self, point_msg):\n        try:\n            # Transform the incoming point\n            transform = self.tf_buffer.lookup_transform(\n                'map',  # Target frame\n                point_msg.header.frame_id,  # Source frame\n                rclpy.time.Time(),  # Time (latest)\n                timeout=rclpy.duration.Duration(seconds=1.0)\n            )\n\n            # Perform the transformation\n            transformed_point = do_transform_point(point_msg, transform)\n            transformed_point.header.frame_id = 'map'\n            transformed_point.header.stamp = self.get_clock().now().to_msg()\n\n            # Publish the transformed point\n            self.pub.publish(transformed_point)\n\n            self.get_logger().info(\n                f'Transformed point from {point_msg.header.frame_id} to map: '\n                f'({point_msg.point.x:.3f}, {point_msg.point.y:.3f}, {point_msg.point.z:.3f}) -> '\n                f'({transformed_point.point.x:.3f}, {transformed_point.point.y:.3f}, {transformed_point.point.z:.3f})'\n            )\n\n        except Exception as e:\n            self.get_logger().error(f'Could not transform point: {str(e)}')\n\n    def transform_sample_point(self):\n        # Create a sample point in base_link frame\n        sample_point = PointStamped()\n        sample_point.header.frame_id = 'base_link'\n        sample_point.header.stamp = self.get_clock().now().to_msg()\n        sample_point.point.x = 1.0  # 1m in front of robot\n        sample_point.point.y = 0.5  # 0.5m to the left\n        sample_point.point.z = 0.0  # on the ground plane\n\n        # Transform it to map frame\n        try:\n            transform = self.tf_buffer.lookup_transform(\n                'map',\n                'base_link',\n                rclpy.time.Time(),\n                timeout=rclpy.duration.Duration(seconds=1.0)\n            )\n\n            transformed = do_transform_point(sample_point, transform)\n            transformed.header.frame_id = 'map'\n            transformed.header.stamp = self.get_clock().now().to_msg()\n\n            self.get_logger().info(\n                f'Sample point transformed: base_link({sample_point.point.x:.3f}, {sample_point.point.y:.3f}) -> '\n                f'map({transformed.point.x:.3f}, {transformed.point.y:.3f})'\n            )\n\n        except Exception as e:\n            self.get_logger().error(f'Could not transform sample point: {str(e)}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    transform_converter = TransformConverter()\n\n    try:\n        rclpy.spin(transform_converter)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        transform_converter.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a node to generate sample points:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_tf/robot_tf/point_generator.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PointStamped\nimport math\n\nclass PointGenerator(Node):\n    def __init__(self):\n        super().__init__('point_generator')\n\n        # Publisher for points to transform\n        self.pub = self.create_publisher(PointStamped, 'input_points', 10)\n\n        # Timer to publish points\n        self.timer = self.create_timer(3.0, self.publish_point)\n        self.counter = 0\n\n    def publish_point(self):\n        # Create a point in different frames to test transformation\n        point = PointStamped()\n\n        if self.counter % 3 == 0:\n            # Point in base_link\n            point.header.frame_id = 'base_link'\n            point.point.x = 1.0\n            point.point.y = 0.0\n            point.point.z = 0.0\n        elif self.counter % 3 == 1:\n            # Point in laser_frame\n            point.header.frame_id = 'laser_frame'\n            point.point.x = 0.0\n            point.point.y = 0.0\n            point.point.z = 1.0  # 1m above laser\n        else:\n            # Point in odom\n            point.header.frame_id = 'odom'\n            point.point.x = 2.0\n            point.point.y = 1.0\n            point.point.z = 0.0\n\n        point.header.stamp = self.get_clock().now().to_msg()\n        self.pub.publish(point)\n\n        self.get_logger().info(\n            f'Published point in {point.header.frame_id}: '\n            f'({point.point.x:.3f}, {point.point.y:.3f}, {point.point.z:.3f})'\n        )\n\n        self.counter += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    point_generator = PointGenerator()\n\n    try:\n        rclpy.spin(point_generator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        point_generator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Build and run the transformation nodes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select robot_tf\nsource install/setup.bash\n\n# Run the transform converter\nros2 run robot_tf transform_converter\n\n# In another terminal, run the point generator\nros2 run robot_tf point_generator\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Test with command line tools:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Publish a point manually\nros2 topic pub /input_points geometry_msgs/PointStamped \"{\n  header: {frame_id: 'base_link'},\n  point: {x: 1.0, y: 0.5, z: 0.0}\n}\"\n"})}),"\n"]}),"\n"]}),(0,r.jsx)(n.h3,{id:"expected-outcome-2",children:"Expected Outcome"}),(0,r.jsx)(n.p,{children:"A system that can transform points between different coordinate frames, with proper error handling and logging."}),(0,r.jsx)(n.h3,{id:"troubleshooting-tips-2",children:"Troubleshooting Tips"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensure TF tree is connected between source and target frames"}),"\n",(0,r.jsx)(n.li,{children:"Check that timestamps in PointStamped messages are appropriate"}),"\n",(0,r.jsx)(n.li,{children:"Verify that the transform listener has enough time to populate the buffer"}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"ros-2-packagestools-used",children:"ROS 2 Packages/Tools Used"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tf2_ros"}),": ROS 2 TF2 library for transform operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tf2_geometry_msgs"}),": TF2 extensions for geometry message transformations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"urdf"})," and ",(0,r.jsx)(n.code,{children:"xacro"})," packages: Robot description and XML macro language"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rviz2"})," for visualization: 3D visualization tool for ROS 2"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"robot_state_publisher"}),": Publishing robot state transforms from URDF"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"simulation-vs-real-robot-activities",children:"Simulation vs Real-Robot Activities"}),"\n",(0,r.jsx)(n.h3,{id:"simulation",children:"Simulation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"TF tree for simulated robot model"}),"\n",(0,r.jsx)(n.li,{children:"Transform validation in simulation environment"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"real-robot",children:"Real Robot:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"TF calibration and validation with real sensors"}),"\n",(0,r.jsx)(n.li,{children:"Real-world coordinate frame transformations"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"diagrams-and-figures",children:"Diagrams and Figures"}),"\n",(0,r.jsx)(n.h3,{id:"tf-tree-visualization-example",children:"TF Tree Visualization Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"        map\n         |\n       odom\n         |\n     base_link\n    /    |    \\\nlaser  imu  wheels\nframe  frame   frames\n"})}),"\n",(0,r.jsx)(n.h3,{id:"coordinate-frame-transformation-mathematics",children:"Coordinate Frame Transformation Mathematics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"P_target = R * P_source + T\n\nWhere:\n- P_target: Point in target coordinate frame\n- P_source: Point in source coordinate frame\n- R: Rotation matrix (from quaternion)\n- T: Translation vector\n"})}),"\n",(0,r.jsx)(n.h3,{id:"urdf-to-tf-relationship-diagram",children:"URDF to TF Relationship Diagram"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"URDF File\n   |\n   v\nrobot_state_publisher\n   |\n   v\nTF Tree in ROS\n   |\n   v\nTransform Lookups\n"})}),"\n",(0,r.jsx)(n.h2,{id:"checklists",children:"Checklists"}),"\n",(0,r.jsx)(n.h3,{id:"-tf-tree-validation-checklist",children:"\u2713 TF Tree Validation Checklist"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All frames are connected in a single tree"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","No loops exist in the transform tree"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Frame names follow ROS naming conventions"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Transform frequencies are appropriate (10-100 Hz)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"-urdf-model-correctness-checklist",children:"\u2713 URDF Model Correctness Checklist"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All links have proper visual and collision properties"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Joint definitions are correct with proper parent-child relationships"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Inertial properties are defined for dynamic simulation"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Frame IDs match between URDF and code"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"-transform-lookup-accuracy-checklist",children:"\u2713 Transform Lookup Accuracy Checklist"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Lookups use appropriate time stamps"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Timeout values are reasonable for system performance"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Error handling implemented for failed lookups"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Transform caching is used appropriately"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"glossary-terms",children:"Glossary Terms"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TF"}),": Transform library for coordinate frame management"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transform"}),": A relationship between two coordinate frames (position and orientation)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Frame"}),": A coordinate system in the TF tree"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"URDF"}),": Unified Robot Description Format for robot models"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Robot State"}),": Joint positions and transforms for robot links"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forward Kinematics"}),": Calculating end-effector position from joint angles"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inverse Kinematics"}),": Calculating joint angles from end-effector position"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"cross-references",children:"Cross-References"}),"\n",(0,r.jsx)(o.A,{to:"/docs/module-1/chapter-4",title:"Chapter 4: Parameters and Launch Systems",type:"prerequisite",children:(0,r.jsx)(n.p,{children:"Understanding launch systems helps in starting TF-related nodes together."})}),"\n",(0,r.jsx)(o.A,{to:"/docs/module-1/chapter-6",title:"Chapter 6: Real-world Integration and Best Practices",type:"continuation",children:(0,r.jsx)(n.p,{children:"Apply TF concepts to real hardware integration and calibration."})}),"\n",(0,r.jsx)(o.A,{to:"/docs/module-2/chapter-1",title:"Module 2, Chapter 1: Introduction to Simulation Environments",type:"application",children:(0,r.jsx)(n.p,{children:"Use TF in simulation environments for robot state and sensor integration."})}),"\n",(0,r.jsx)(n.h2,{id:"optional-advanced-section",children:"Optional Advanced Section"}),"\n",(0,r.jsx)(n.h3,{id:"tf-interpolation-and-buffering-strategies",children:"TF Interpolation and Buffering Strategies"}),"\n",(0,r.jsx)(n.p,{children:"Advanced techniques for handling transform lookups with proper buffering and interpolation."}),"\n",(0,r.jsx)(n.h3,{id:"multi-robot-tf-management",children:"Multi-robot TF Management"}),"\n",(0,r.jsx)(n.p,{children:"Managing coordinate frames for multiple robots operating in the same environment."}),"\n",(0,r.jsxs)(c.A,{type:"assignment",title:"Chapter 5 Assessment: TF and Navigation Fundamentals",objectives:["Create and validate URDF models with proper TF frames","Implement TF broadcasters for robot state","Perform coordinate frame transformations","Visualize and debug TF trees"],rubric:[{criterion:"URDF Model Creation",scores:[{label:"Excellent",value:"URDF properly structured with correct frames and properties"},{label:"Proficient",value:"URDF functional with minor issues"},{label:"Developing",value:"URDF partially correct"},{label:"Beginning",value:"URDF not properly structured"}]},{criterion:"TF Broadcasting",scores:[{label:"Excellent",value:"TF broadcasters properly implemented with dynamic updates"},{label:"Proficient",value:"TF broadcasters functional with minor issues"},{label:"Developing",value:"TF broadcasters partially implemented"},{label:"Beginning",value:"TF broadcasters not properly implemented"}]},{criterion:"Transform Operations",scores:[{label:"Excellent",value:"Transformations accurate with proper error handling"},{label:"Proficient",value:"Transformations work with minor issues"},{label:"Developing",value:"Transformations partially functional"},{label:"Beginning",value:"Transformations not properly implemented"}]}],children:[(0,r.jsx)(n.h3,{id:"assignment-tasks",children:"Assignment Tasks"}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"URDF Development"}),": Create a complete URDF model for a robot with at least 5 links and 4 joints, including proper visual, collision, and inertial properties."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"TF Broadcasting"}),": Implement TF broadcasters that publish transforms based on robot odometry and joint states with proper timing."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Coordinate Transformation"}),": Create a system that can transform points between multiple coordinate frames with validation and error handling."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"TF Visualization"}),": Use RViz to visualize the TF tree and validate the coordinate frame relationships."]}),"\n"]}),"\n"]}),(0,r.jsx)(n.h3,{id:"submission-requirements",children:"Submission Requirements"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Complete URDF file for the robot model"}),"\n",(0,r.jsx)(n.li,{children:"Source code for TF broadcasters"}),"\n",(0,r.jsx)(n.li,{children:"Documentation of transform validation"}),"\n",(0,r.jsx)(n.li,{children:"Screenshots of TF visualization in RViz"}),"\n",(0,r.jsx)(n.li,{children:"Test results showing successful coordinate transformations"}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(l.A,{id:"ros2-tf2-design-2021",authors:"Open Robotics",year:"2021",title:"ROS 2 TF2 Design",source:"ROS 2 Documentation",url:"https://docs.ros.org/en/rolling/Concepts/About-TF2.html",children:(0,r.jsx)(n.p,{children:"The official ROS 2 documentation on TF2 explaining coordinate frame management."})}),"\n",(0,r.jsx)(l.A,{id:"urdf-specification-2021",authors:"Open Robotics",year:"2021",title:"URDF Specification",source:"ROS 2 Documentation",url:"https://wiki.ros.org/urdf/XML",children:(0,r.jsx)(n.p,{children:"The URDF specification for robot description format."})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(_,{...e})}):_(e)}},3466(e,n,t){t.d(n,{A:()=>p});t(6540);var r=t(4164),s=t(5489);const i="container_wR2L",a="content_Ku25",o="refType_eLMv",l="refLink_Ya_s",c="description_kDwm",d="icon_D_OF";var m=t(4848);const p=({to:e,title:n,type:t="section",children:p})=>(0,m.jsxs)("div",{className:(0,r.A)("cross-reference-container",i),children:[(0,m.jsxs)("div",{className:a,children:[(0,m.jsxs)("span",{className:o,children:[t.toUpperCase(),":"]}),(0,m.jsx)(s.A,{to:e,className:l,children:n}),p&&(0,m.jsx)("div",{className:c,children:p})]}),(0,m.jsx)("span",{className:d,children:"\ud83d\udd17"})]})},6274(e,n,t){t.d(n,{A:()=>a});t(6540);var r=t(4164);const s={container:"container_O8RR",header:"header_LgZa",titleSection:"titleSection_gyi3",icon:"icon_yEVu",title:"title_gwcA",sectionTitle:"sectionTitle_DWTK",objectivesList:"objectivesList_djML",objectiveItem:"objectiveItem_L9Jm",rubricGrid:"rubricGrid_oK2H",rubricItem:"rubricItem_Y0lq",criterion:"criterion_Y4sy",scores:"scores_dKwu",score:"score_dpSq",scoreLabel:"scoreLabel_e9ZM",scoreValue:"scoreValue_nfuE",content:"content_qJ2r"};var i=t(4848);const a=({type:e="quiz",title:n,objectives:t,rubric:a,children:o})=>(0,i.jsxs)("div",{className:(0,r.A)("assessment-container",s.container),children:[(0,i.jsx)("div",{className:s.header,children:(0,i.jsxs)("div",{className:s.titleSection,children:[(0,i.jsx)("span",{className:s.icon,children:"\ud83d\udcdd"}),(0,i.jsxs)("h3",{className:s.title,children:[e.charAt(0).toUpperCase()+e.slice(1),": ",n]})]})}),t&&t.length>0&&(0,i.jsxs)("div",{className:s.objectivesSection,children:[(0,i.jsx)("h4",{className:s.sectionTitle,children:"Learning Objectives"}),(0,i.jsx)("ul",{className:s.objectivesList,children:t.map((e,n)=>(0,i.jsx)("li",{className:s.objectiveItem,children:e},n))})]}),a&&(0,i.jsxs)("div",{className:s.rubricSection,children:[(0,i.jsx)("h4",{className:s.sectionTitle,children:"Assessment Rubric"}),(0,i.jsx)("div",{className:s.rubricGrid,children:a.map((e,n)=>(0,i.jsxs)("div",{className:s.rubricItem,children:[(0,i.jsx)("div",{className:s.criterion,children:e.criterion}),(0,i.jsx)("div",{className:s.scores,children:e.scores.map((e,n)=>(0,i.jsxs)("div",{className:s.score,children:[(0,i.jsxs)("span",{className:s.scoreLabel,children:[e.label,":"]}),(0,i.jsx)("span",{className:s.scoreValue,children:e.value})]},n))})]},n))})]}),(0,i.jsx)("div",{className:s.content,children:o})]})},7944(e,n,t){t.d(n,{A:()=>p});t(6540);var r=t(4164);const s="container_MRjH",i="citationContent_jj7V",a="citationText_bXIf",o="citationId_auqD",l="urlLink_ZvkM",c="description_pgVT",d="icon_HjvY";var m=t(4848);const p=({id:e,authors:n,year:t,title:p,source:f,url:h,children:_})=>(0,m.jsxs)("div",{className:(0,r.A)("citation-container",s),children:[(0,m.jsxs)("div",{className:i,children:[(0,m.jsxs)("div",{className:a,children:[(0,m.jsxs)("span",{className:o,children:["[",e,"]"]})," ",n," (",t,"). ",p,". ",f,".",h&&" Available at: ",h&&(0,m.jsx)("a",{href:h,className:l,target:"_blank",rel:"noopener noreferrer",children:h})]}),_&&(0,m.jsx)("div",{className:c,children:_})]}),(0,m.jsx)("span",{className:d,children:"\ud83d\udcda"})]})},8415(e,n,t){t.d(n,{A:()=>m});t(6540);var r=t(4164);const s="container_IT7u",i="header_CZcX",a="icon_E6M3",o="title_MIoE",l="objectivesList_NPeG",c="objectiveItem_Pr17";var d=t(4848);const m=({objectives:e,title:n="Learning Objectives"})=>(0,d.jsxs)("div",{className:(0,r.A)("learning-objectives-container",s),children:[(0,d.jsxs)("div",{className:i,children:[(0,d.jsx)("span",{className:a,children:"\ud83c\udfaf"}),(0,d.jsx)("h3",{className:o,children:n})]}),(0,d.jsx)("ul",{className:l,children:e.map((e,n)=>(0,d.jsx)("li",{className:c,children:e},n))})]})},8453(e,n,t){t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);