"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[429],{1473(e,n,t){t.d(n,{A:()=>g});t(6540);var s=t(4164);const r="container_DYDm",a="header_yOrC",i="titleSection_jiBk",o="icon_OiJW",l="title_bD_B",c="meta_N7Me",d="time_Cevp",m="difficulty_aRrW",p="content_CCam";var u=t(4848);const g=({title:e,time:n,difficulty:t,children:g})=>(0,u.jsxs)("div",{className:(0,s.A)("lab-activity-container",r),children:[(0,u.jsxs)("div",{className:a,children:[(0,u.jsxs)("div",{className:i,children:[(0,u.jsx)("span",{className:o,children:"\ud83e\uddea"}),(0,u.jsx)("h3",{className:l,children:e||"Lab Activity"})]}),(0,u.jsxs)("div",{className:c,children:[n&&(0,u.jsxs)("span",{className:d,children:["\u23f1\ufe0f ",n]}),t&&(0,u.jsxs)("span",{className:m,children:["\ud83c\udfaf ",t]})]})]}),(0,u.jsx)("div",{className:p,children:g})]})},3466(e,n,t){t.d(n,{A:()=>p});t(6540);var s=t(4164),r=t(5489);const a="container_wR2L",i="content_Ku25",o="refType_eLMv",l="refLink_Ya_s",c="description_kDwm",d="icon_D_OF";var m=t(4848);const p=({to:e,title:n,type:t="section",children:p})=>(0,m.jsxs)("div",{className:(0,s.A)("cross-reference-container",a),children:[(0,m.jsxs)("div",{className:i,children:[(0,m.jsxs)("span",{className:o,children:[t.toUpperCase(),":"]}),(0,m.jsx)(r.A,{to:e,className:l,children:n}),p&&(0,m.jsx)("div",{className:c,children:p})]}),(0,m.jsx)("span",{className:d,children:"\ud83d\udd17"})]})},6274(e,n,t){t.d(n,{A:()=>i});t(6540);var s=t(4164);const r={container:"container_O8RR",header:"header_LgZa",titleSection:"titleSection_gyi3",icon:"icon_yEVu",title:"title_gwcA",sectionTitle:"sectionTitle_DWTK",objectivesList:"objectivesList_djML",objectiveItem:"objectiveItem_L9Jm",rubricGrid:"rubricGrid_oK2H",rubricItem:"rubricItem_Y0lq",criterion:"criterion_Y4sy",scores:"scores_dKwu",score:"score_dpSq",scoreLabel:"scoreLabel_e9ZM",scoreValue:"scoreValue_nfuE",content:"content_qJ2r"};var a=t(4848);const i=({type:e="quiz",title:n,objectives:t,rubric:i,children:o})=>(0,a.jsxs)("div",{className:(0,s.A)("assessment-container",r.container),children:[(0,a.jsx)("div",{className:r.header,children:(0,a.jsxs)("div",{className:r.titleSection,children:[(0,a.jsx)("span",{className:r.icon,children:"\ud83d\udcdd"}),(0,a.jsxs)("h3",{className:r.title,children:[e.charAt(0).toUpperCase()+e.slice(1),": ",n]})]})}),t&&t.length>0&&(0,a.jsxs)("div",{className:r.objectivesSection,children:[(0,a.jsx)("h4",{className:r.sectionTitle,children:"Learning Objectives"}),(0,a.jsx)("ul",{className:r.objectivesList,children:t.map((e,n)=>(0,a.jsx)("li",{className:r.objectiveItem,children:e},n))})]}),i&&(0,a.jsxs)("div",{className:r.rubricSection,children:[(0,a.jsx)("h4",{className:r.sectionTitle,children:"Assessment Rubric"}),(0,a.jsx)("div",{className:r.rubricGrid,children:i.map((e,n)=>(0,a.jsxs)("div",{className:r.rubricItem,children:[(0,a.jsx)("div",{className:r.criterion,children:e.criterion}),(0,a.jsx)("div",{className:r.scores,children:e.scores.map((e,n)=>(0,a.jsxs)("div",{className:r.score,children:[(0,a.jsxs)("span",{className:r.scoreLabel,children:[e.label,":"]}),(0,a.jsx)("span",{className:r.scoreValue,children:e.value})]},n))})]},n))})]}),(0,a.jsx)("div",{className:r.content,children:o})]})},7367(e,n,t){t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>m,default:()=>h,frontMatter:()=>d,metadata:()=>p,toc:()=>g});var s=t(4848),r=t(8453),a=t(8415),i=t(1473),o=t(3466),l=t(7944),c=t(6274);const d={sidebar_position:7},m="Chapter 6: Real-world Integration and Best Practices",p={id:"module-1/chapter-6",title:"Chapter 6: Real-world Integration and Best Practices",description:"Chapter Purpose",source:"@site/docs/module-1/chapter-6.md",sourceDirName:"module-1",slug:"/module-1/chapter-6",permalink:"/hackathon_project1/docs/module-1/chapter-6",draft:!1,unlisted:!1,editUrl:"https://github.com/physical-ai-robotics-book/physical-ai-robotics-book/tree/main/docusaurus/docs/module-1/chapter-6.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"textbookSidebar",previous:{title:"Chapter 5: TF and Navigation Fundamentals",permalink:"/hackathon_project1/docs/module-1/chapter-5"},next:{title:"Module 1 Assessment and Integration",permalink:"/hackathon_project1/docs/module-1/module-assessment"}},u={},g=[{value:"Chapter Purpose",id:"chapter-purpose",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Practical Demonstrations",id:"practical-demonstrations",level:2},{value:"1. Creating a Driver for a Simple Sensor",id:"1-creating-a-driver-for-a-simple-sensor",level:3},{value:"2. Hardware Abstraction Layer Implementation",id:"2-hardware-abstraction-layer-implementation",level:3},{value:"3. System Monitoring and Logging Configuration",id:"3-system-monitoring-and-logging-configuration",level:3},{value:"Hands-on Coding Labs",id:"hands-on-coding-labs",level:2},{value:"Objective",id:"objective",level:3},{value:"Steps",id:"steps",level:3},{value:"Expected Outcome",id:"expected-outcome",level:3},{value:"Troubleshooting Tips",id:"troubleshooting-tips",level:3},{value:"Objective",id:"objective-1",level:3},{value:"Steps",id:"steps-1",level:3},{value:"Expected Outcome",id:"expected-outcome-1",level:3},{value:"Troubleshooting Tips",id:"troubleshooting-tips-1",level:3},{value:"Objective",id:"objective-2",level:3},{value:"Steps",id:"steps-2",level:3},{value:"Expected Outcome",id:"expected-outcome-2",level:3},{value:"Troubleshooting Tips",id:"troubleshooting-tips-2",level:3},{value:"ROS 2 Packages/Tools Used",id:"ros-2-packagestools-used",level:2},{value:"Simulation vs Real-Robot Activities",id:"simulation-vs-real-robot-activities",level:2},{value:"Simulation:",id:"simulation",level:3},{value:"Real Robot:",id:"real-robot",level:3},{value:"Diagrams and Figures",id:"diagrams-and-figures",level:2},{value:"Hardware Abstraction Layer Architecture",id:"hardware-abstraction-layer-architecture",level:3},{value:"Driver Interface Design Patterns",id:"driver-interface-design-patterns",level:3},{value:"Performance Profiling Workflow",id:"performance-profiling-workflow",level:3},{value:"Checklists",id:"checklists",level:2},{value:"\u2713 Hardware Integration Validation Checklist",id:"-hardware-integration-validation-checklist",level:3},{value:"\u2713 Performance Optimization Checklist",id:"-performance-optimization-checklist",level:3},{value:"\u2713 Documentation and Testing Checklist",id:"-documentation-and-testing-checklist",level:3},{value:"Glossary Terms",id:"glossary-terms",level:2},{value:"Cross-References",id:"cross-references",level:2},{value:"Optional Advanced Section",id:"optional-advanced-section",level:2},{value:"Real-time Constraints and RT Kernel Configuration",id:"real-time-constraints-and-rt-kernel-configuration",level:3},{value:"Distributed ROS 2 Systems Across Multiple Machines",id:"distributed-ros-2-systems-across-multiple-machines",level:3},{value:"Assignment Tasks",id:"assignment-tasks",level:3},{value:"Submission Requirements",id:"submission-requirements",level:3},{value:"References",id:"references",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"chapter-6-real-world-integration-and-best-practices",children:"Chapter 6: Real-world Integration and Best Practices"}),"\n","\n","\n",(0,s.jsx)(n.h2,{id:"chapter-purpose",children:"Chapter Purpose"}),"\n",(0,s.jsx)(n.p,{children:"This chapter covers hardware abstraction layer design, driver development and integration, system monitoring and logging, and performance optimization techniques for real-world robotic systems. Students will learn to implement hardware abstraction interfaces, create drivers for sensors and actuators, set up diagnostic systems, and optimize performance for production environments. The chapter emphasizes best practices for deploying robotic systems in real-world scenarios."}),"\n",(0,s.jsx)(a.A,{objectives:["Implement hardware abstraction layer design for sensor and actuator integration","Develop drivers for simple sensors following ROS 2 best practices","Set up system monitoring and logging for robotic applications","Optimize performance and implement debugging strategies for production systems","Apply real-time constraints and RT kernel configuration for time-critical applications"]}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hardware abstraction layer design"}),": Creating interfaces that separate hardware-specific code from application logic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Driver development and integration"}),": Writing ROS 2 nodes that interface with physical hardware"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System monitoring and logging"}),": Implementing diagnostic and monitoring systems for robotic applications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance optimization and debugging"}),": Techniques for optimizing and debugging robotic systems"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"practical-demonstrations",children:"Practical Demonstrations"}),"\n",(0,s.jsx)(n.h3,{id:"1-creating-a-driver-for-a-simple-sensor",children:"1. Creating a Driver for a Simple Sensor"}),"\n",(0,s.jsx)(n.p,{children:"Creating a driver for a basic sensor like an IMU:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# imu_driver.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nfrom std_msgs.msg import Header\nimport math\nimport time\n\nclass ImuDriver(Node):\n    def __init__(self):\n        super().__init__('imu_driver')\n\n        # Create publisher for IMU data\n        self.publisher = self.create_publisher(Imu, 'imu/data_raw', 10)\n\n        # Create timer for publishing data\n        self.timer = self.create_timer(0.02, self.publish_imu_data)  # 50 Hz\n\n        # Initialize sensor data\n        self.roll = 0.0\n        self.pitch = 0.0\n        self.yaw = 0.0\n        self.sequence = 0\n\n        self.get_logger().info('IMU Driver initialized')\n\n    def publish_imu_data(self):\n        # Simulate IMU data (in a real driver, this would read from hardware)\n        self.roll += 0.01\n        self.pitch += 0.005\n        self.yaw += 0.002\n\n        # Create IMU message\n        msg = Imu()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'imu_link'\n        msg.header.seq = self.sequence\n        self.sequence += 1\n\n        # Convert Euler angles to quaternion\n        cy = math.cos(self.yaw * 0.5)\n        sy = math.sin(self.yaw * 0.5)\n        cp = math.cos(self.pitch * 0.5)\n        sp = math.sin(self.pitch * 0.5)\n        cr = math.cos(self.roll * 0.5)\n        sr = math.sin(self.roll * 0.5)\n\n        msg.orientation.x = sr * cp * cy - cr * sp * sy\n        msg.orientation.y = cr * sp * cy + sr * cp * sy\n        msg.orientation.z = cr * cp * sy - sr * sp * cy\n        msg.orientation.w = cr * cp * cy + sr * sp * sy\n\n        # Angular velocity (simulated)\n        msg.angular_velocity.x = 0.1\n        msg.angular_velocity.y = 0.05\n        msg.angular_velocity.z = 0.02\n\n        # Linear acceleration (simulated)\n        msg.linear_acceleration.x = 0.0\n        msg.linear_acceleration.y = 0.0\n        msg.linear_acceleration.z = 9.81  # Gravity\n\n        # Covariances (set to 0 for simplicity, in real application these would be set appropriately)\n        msg.orientation_covariance = [0.0] * 9\n        msg.angular_velocity_covariance = [0.0] * 9\n        msg.linear_acceleration_covariance = [0.0] * 9\n\n        # Publish the message\n        self.publisher.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    imu_driver = ImuDriver()\n\n    try:\n        rclpy.spin(imu_driver)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        imu_driver.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-hardware-abstraction-layer-implementation",children:"2. Hardware Abstraction Layer Implementation"}),"\n",(0,s.jsx)(n.p,{children:"Creating a hardware abstraction interface:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# hardware_interface.py\nfrom abc import ABC, abstractmethod\n\nclass HardwareInterface(ABC):\n    """Abstract base class for hardware interfaces"""\n\n    @abstractmethod\n    def initialize(self):\n        """Initialize the hardware"""\n        pass\n\n    @abstractmethod\n    def read_sensors(self):\n        """Read sensor data from hardware"""\n        pass\n\n    @abstractmethod\n    def write_actuators(self, commands):\n        """Write commands to actuators"""\n        pass\n\n    @abstractmethod\n    def shutdown(self):\n        """Clean shutdown of hardware"""\n        pass\n\nclass MockHardwareInterface(HardwareInterface):\n    """Mock implementation for testing"""\n\n    def __init__(self):\n        self.position = 0.0\n        self.velocity = 0.0\n        self.effort = 0.0\n\n    def initialize(self):\n        print("Mock hardware initialized")\n        return True\n\n    def read_sensors(self):\n        # Simulate reading sensor data\n        return {\n            \'position\': self.position,\n            \'velocity\': self.velocity,\n            \'effort\': self.effort\n        }\n\n    def write_actuators(self, commands):\n        # Simulate writing to actuators\n        self.position = commands.get(\'position\', self.position)\n        self.velocity = commands.get(\'velocity\', self.velocity)\n        self.effort = commands.get(\'effort\', self.effort)\n\n    def shutdown(self):\n        print("Mock hardware shutdown")\n        return True\n\n# robot_hardware_interface.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64\nfrom sensor_msgs.msg import JointState\n\nclass RobotHardwareInterface(Node):\n    def __init__(self, hardware_interface):\n        super().__init__(\'robot_hardware_interface\')\n\n        # Store hardware interface\n        self.hw_interface = hardware_interface\n\n        # Initialize hardware\n        if not self.hw_interface.initialize():\n            self.get_logger().error(\'Failed to initialize hardware\')\n            return\n\n        # Create publishers and subscribers\n        self.joint_state_pub = self.create_publisher(JointState, \'joint_states\', 10)\n        self.motor_cmd_sub = self.create_subscription(\n            Float64,\n            \'motor_command\',\n            self.motor_cmd_callback,\n            10\n        )\n\n        # Create timer for reading hardware\n        self.timer = self.create_timer(0.01, self.read_hardware)  # 100 Hz\n\n    def motor_cmd_callback(self, msg):\n        """Handle motor command"""\n        commands = {\'position\': msg.data}\n        self.hw_interface.write_actuators(commands)\n\n    def read_hardware(self):\n        """Read hardware state and publish joint states"""\n        sensor_data = self.hw_interface.read_sensors()\n\n        # Create joint state message\n        joint_state = JointState()\n        joint_state.header.stamp = self.get_clock().now().to_msg()\n        joint_state.name = [\'joint1\']\n        joint_state.position = [sensor_data[\'position\']]\n        joint_state.velocity = [sensor_data[\'velocity\']]\n        joint_state.effort = [sensor_data[\'effort\']]\n\n        self.joint_state_pub.publish(joint_state)\n\n    def destroy_node(self):\n        """Override destroy to ensure hardware shutdown"""\n        self.hw_interface.shutdown()\n        super().destroy_node()\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    # Create hardware interface\n    hw_interface = MockHardwareInterface()\n\n    # Create robot hardware interface\n    robot_hw_interface = RobotHardwareInterface(hw_interface)\n\n    try:\n        rclpy.spin(robot_hw_interface)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        robot_hw_interface.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-system-monitoring-and-logging-configuration",children:"3. System Monitoring and Logging Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Setting up diagnostic systems:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# system_monitor.py\nimport rclpy\nfrom rclpy.node import Node\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue\nfrom std_msgs.msg import Header\nimport psutil\nimport socket\nimport time\n\nclass SystemMonitor(Node):\n    def __init__(self):\n        super().__init__('system_monitor')\n\n        # Create publisher for diagnostics\n        self.diag_pub = self.create_publisher(DiagnosticArray, '/diagnostics', 10)\n\n        # Create timer for publishing diagnostics\n        self.timer = self.create_timer(1.0, self.publish_diagnostics)\n\n        self.get_logger().info('System Monitor initialized')\n\n    def publish_diagnostics(self):\n        # Create diagnostic array\n        diag_array = DiagnosticArray()\n        diag_array.header = Header()\n        diag_array.header.stamp = self.get_clock().now().to_msg()\n\n        # System status\n        system_status = DiagnosticStatus()\n        system_status.name = f'{socket.gethostname()}_system_status'\n        system_status.hardware_id = socket.gethostname()\n\n        # CPU usage\n        cpu_percent = psutil.cpu_percent()\n        system_status.values.append(KeyValue(key='CPU Usage (%)', value=str(cpu_percent)))\n\n        # Memory usage\n        memory = psutil.virtual_memory()\n        system_status.values.append(KeyValue(key='Memory Usage (%)', value=str(memory.percent)))\n        system_status.values.append(KeyValue(key='Memory Available (MB)', value=str(memory.available / 1024 / 1024)))\n\n        # Disk usage\n        disk = psutil.disk_usage('/')\n        system_status.values.append(KeyValue(key='Disk Usage (%)', value=str(disk.percent)))\n\n        # Determine overall status\n        if cpu_percent > 90 or memory.percent > 90:\n            system_status.level = DiagnosticStatus.ERROR\n            system_status.message = 'High resource usage detected'\n        elif cpu_percent > 70 or memory.percent > 70:\n            system_status.level = DiagnosticStatus.WARN\n            system_status.message = 'Moderate resource usage'\n        else:\n            system_status.level = DiagnosticStatus.OK\n            system_status.message = 'System operating normally'\n\n        diag_array.status.append(system_status)\n\n        # ROS-specific diagnostics\n        ros_status = DiagnosticStatus()\n        ros_status.name = 'ROS_2_Node_Status'\n        ros_status.hardware_id = 'ros2_node'\n        ros_status.level = DiagnosticStatus.OK\n        ros_status.message = 'Node running normally'\n        ros_status.values.append(KeyValue(key='Node Name', value=self.get_name()))\n        ros_status.values.append(KeyValue(key='Node Namespace', value=self.get_namespace()))\n\n        diag_array.status.append(ros_status)\n\n        # Publish diagnostics\n        self.diag_pub.publish(diag_array)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    system_monitor = SystemMonitor()\n\n    try:\n        rclpy.spin(system_monitor)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        system_monitor.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"hands-on-coding-labs",children:"Hands-on Coding Labs"}),"\n",(0,s.jsxs)(i.A,{title:"Lab 6.1: Creating a Driver for a Simple Sensor",time:"60 min",difficulty:"Hard",children:[(0,s.jsx)(n.h3,{id:"objective",children:"Objective"}),(0,s.jsx)(n.p,{children:"Create a complete ROS 2 driver for a simple sensor (e.g., temperature sensor, light sensor) following ROS 2 best practices."}),(0,s.jsx)(n.h3,{id:"steps",children:"Steps"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create a new package for the sensor driver:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python sensor_drivers\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create the temperature sensor driver:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/sensor_drivers/sensor_drivers/temperature_sensor_driver.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Temperature\nfrom std_msgs.msg import Header\nimport random\nimport time\n\nclass TemperatureSensorDriver(Node):\n    def __init__(self):\n        super().__init__('temperature_sensor_driver')\n\n        # Declare parameters\n        self.declare_parameter('sensor_id', 'temp_sensor_01')\n        self.declare_parameter('frame_id', 'temperature_sensor')\n        self.declare_parameter('publish_rate', 10.0)  # Hz\n        self.declare_parameter('base_temperature', 25.0)  # degrees C\n        self.declare_parameter('temperature_variance', 2.0)  # variance in degrees\n\n        # Get parameters\n        self.sensor_id = self.get_parameter('sensor_id').value\n        self.frame_id = self.get_parameter('frame_id').value\n        publish_rate = self.get_parameter('publish_rate').value\n        self.base_temp = self.get_parameter('base_temperature').value\n        self.temp_variance = self.get_parameter('temperature_variance').value\n\n        # Create publisher\n        self.publisher = self.create_publisher(Temperature, 'temperature', 10)\n\n        # Create timer\n        self.timer = self.create_timer(1.0/publish_rate, self.publish_temperature)\n\n        # Initialize sequence counter\n        self.sequence = 0\n\n        self.get_logger().info(\n            f'Temperature sensor driver initialized:\\n'\n            f'  Sensor ID: {self.sensor_id}\\n'\n            f'  Frame ID: {self.frame_id}\\n'\n            f'  Publish rate: {publish_rate} Hz\\n'\n            f'  Base temp: {self.base_temp}\xb0C\\n'\n            f'  Variance: \xb1{self.temp_variance}\xb0C'\n        )\n\n    def publish_temperature(self):\n        # Create temperature message\n        msg = Temperature()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = self.frame_id\n        msg.header.seq = self.sequence\n        self.sequence += 1\n\n        # Simulate temperature reading with some randomness\n        current_temp = self.base_temp + random.uniform(-self.temp_variance, self.temp_variance)\n        msg.temperature = current_temp\n\n        # In a real sensor, uncertainty would be specified\n        msg.variance = 0.0  # For simulated sensor\n\n        # Publish the message\n        self.publisher.publish(msg)\n\n        # Log the reading\n        self.get_logger().debug(f'Temperature reading: {current_temp:.2f}\xb0C')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    temp_sensor_driver = TemperatureSensorDriver()\n\n    try:\n        rclpy.spin(temp_sensor_driver)\n    except KeyboardInterrupt:\n        temp_sensor_driver.get_logger().info('Shutting down temperature sensor driver...')\n    finally:\n        temp_sensor_driver.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create a launch file for the temperature sensor:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/sensor_drivers/launch/temperature_sensor.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Declare launch arguments\n    sensor_id = LaunchConfiguration('sensor_id')\n    frame_id = LaunchConfiguration('frame_id')\n    publish_rate = LaunchConfiguration('publish_rate')\n\n    sensor_id_arg = DeclareLaunchArgument(\n        'sensor_id',\n        default_value='temp_sensor_01',\n        description='Unique ID for the temperature sensor'\n    )\n\n    frame_id_arg = DeclareLaunchArgument(\n        'frame_id',\n        default_value='temperature_sensor',\n        description='TF frame for the temperature sensor'\n    )\n\n    publish_rate_arg = DeclareLaunchArgument(\n        'publish_rate',\n        default_value='10.0',\n        description='Publish rate for temperature readings (Hz)'\n    )\n\n    # Create temperature sensor driver node\n    temp_sensor_node = Node(\n        package='sensor_drivers',\n        executable='temperature_sensor_driver',\n        name='temperature_sensor_driver',\n        parameters=[\n            {'sensor_id': sensor_id},\n            {'frame_id': frame_id},\n            {'publish_rate': publish_rate}\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        sensor_id_arg,\n        frame_id_arg,\n        publish_rate_arg,\n        temp_sensor_node\n    ])\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create a setup.py file for the package:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/sensor_drivers/setup.py\nfrom setuptools import find_packages, setup\n\npackage_name = 'sensor_drivers'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=find_packages(exclude=['test']),\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        ('share/' + package_name + '/launch', ['launch/temperature_sensor.launch.py']),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='Your Name',\n    maintainer_email='your.email@example.com',\n    description='ROS 2 sensor drivers package',\n    license='Apache-2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'temperature_sensor_driver = sensor_drivers.temperature_sensor_driver:main',\n        ],\n    },\n)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create a package.xml file:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\n<package format="3">\n  <name>sensor_drivers</name>\n  <version>0.0.0</version>\n  <description>ROS 2 sensor drivers package</description>\n  <maintainer email="your.email@example.com">Your Name</maintainer>\n  <license>Apache-2.0</license>\n\n  <depend>rclpy</depend>\n  <depend>sensor_msgs</depend>\n  <depend>std_msgs</depend>\n\n  <test_depend>ament_copyright</test_depend>\n  <test_depend>ament_flake8</test_depend>\n  <test_depend>ament_pep257</test_depend>\n  <test_depend>python3-pytest</test_depend>\n\n  <export>\n    <build_type>ament_python</build_type>\n  </export>\n</package>\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Build and test the temperature sensor driver:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select sensor_drivers\nsource install/setup.bash\n\n# Run the temperature sensor driver\nros2 run sensor_drivers temperature_sensor_driver\n\n# Or use the launch file\nros2 launch sensor_drivers temperature_sensor.launch.py\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Test the sensor output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Echo the temperature topic\nros2 topic echo /temperature sensor_msgs/msg/Temperature\n\n# Check the node status\nros2 node info /temperature_sensor_driver\n"})}),"\n"]}),"\n"]}),(0,s.jsx)(n.h3,{id:"expected-outcome",children:"Expected Outcome"}),(0,s.jsx)(n.p,{children:"A complete ROS 2 driver for a temperature sensor that publishes Temperature messages with proper headers, parameters, and logging."}),(0,s.jsx)(n.h3,{id:"troubleshooting-tips",children:"Troubleshooting Tips"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ensure sensor_msgs dependency is properly declared in package.xml"}),"\n",(0,s.jsx)(n.li,{children:"Check that the executable is properly registered in setup.py"}),"\n",(0,s.jsx)(n.li,{children:"Verify that parameters are correctly declared and used"}),"\n"]})]}),"\n",(0,s.jsxs)(i.A,{title:"Lab 6.2: Hardware Abstraction Layer Implementation",time:"75 min",difficulty:"Hard",children:[(0,s.jsx)(n.h3,{id:"objective-1",children:"Objective"}),(0,s.jsx)(n.p,{children:"Implement a comprehensive hardware abstraction layer that can interface with different types of hardware while maintaining a consistent interface."}),(0,s.jsx)(n.h3,{id:"steps-1",children:"Steps"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create the hardware interface abstract base classes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# ~/ros2_ws/src/robot_control/robot_control/hardware_interface.py\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, Optional\nimport time\n\nclass HardwareInterface(ABC):\n    """Abstract base class for all hardware interfaces"""\n\n    @abstractmethod\n    def initialize(self) -> bool:\n        """Initialize the hardware interface. Returns True if successful."""\n        pass\n\n    @abstractmethod\n    def read(self) -> Dict[str, Any]:\n        """Read current state from hardware. Returns dictionary of sensor values."""\n        pass\n\n    @abstractmethod\n    def write(self, commands: Dict[str, Any]) -> bool:\n        """Write commands to hardware. Returns True if successful."""\n        pass\n\n    @abstractmethod\n    def shutdown(self) -> bool:\n        """Shutdown the hardware interface safely. Returns True if successful."""\n        pass\n\n    @abstractmethod\n    def get_status(self) -> Dict[str, Any]:\n        """Get current status of the hardware interface."""\n        pass\n\nclass JointHardwareInterface(HardwareInterface):\n    """Hardware interface for joint-based systems"""\n\n    def __init__(self, joint_names: list):\n        super().__init__()\n        self.joint_names = joint_names\n        self.initialized = False\n        self.last_read_time = None\n        self.last_write_time = None\n\n    def initialize(self) -> bool:\n        """Initialize joint hardware"""\n        try:\n            # Initialize hardware connections\n            self._initialize_hardware()\n            self.initialized = True\n            self.last_read_time = time.time()\n            self.last_write_time = time.time()\n            return True\n        except Exception as e:\n            print(f"Failed to initialize joint hardware: {e}")\n            return False\n\n    def _initialize_hardware(self):\n        """Internal method to initialize hardware-specific connections"""\n        # This would contain hardware-specific initialization code\n        pass\n\n    def read(self) -> Dict[str, Any]:\n        """Read joint states from hardware"""\n        if not self.initialized:\n            raise RuntimeError("Hardware not initialized")\n\n        # Update read time\n        self.last_read_time = time.time()\n\n        # Return mock joint states (in real implementation, this would read from hardware)\n        joint_states = {}\n        for joint_name in self.joint_names:\n            joint_states[f\'{joint_name}/position\'] = 0.0\n            joint_states[f\'{joint_name}/velocity\'] = 0.0\n            joint_states[f\'{joint_name}/effort\'] = 0.0\n\n        return joint_states\n\n    def write(self, commands: Dict[str, Any]) -> bool:\n        """Write commands to joint hardware"""\n        if not self.initialized:\n            raise RuntimeError("Hardware not initialized")\n\n        # Update write time\n        self.last_write_time = time.time()\n\n        # Process commands (in real implementation, this would write to hardware)\n        for joint_name in self.joint_names:\n            pos_cmd = commands.get(f\'{joint_name}/position\')\n            vel_cmd = commands.get(f\'{joint_name}/velocity\')\n            eff_cmd = commands.get(f\'{joint_name}/effort\')\n\n            # In real implementation, send commands to hardware\n            if pos_cmd is not None:\n                print(f"Commanding {joint_name} position: {pos_cmd}")\n            if vel_cmd is not None:\n                print(f"Commanding {joint_name} velocity: {vel_cmd}")\n            if eff_cmd is not None:\n                print(f"Commanding {joint_name} effort: {eff_cmd}")\n\n        return True\n\n    def shutdown(self) -> bool:\n        """Shutdown joint hardware safely"""\n        try:\n            # Send stop commands to all joints\n            stop_commands = {}\n            for joint_name in self.joint_names:\n                stop_commands[f\'{joint_name}/position\'] = 0.0\n                stop_commands[f\'{joint_name}/velocity\'] = 0.0\n                stop_commands[f\'{joint_name}/effort\'] = 0.0\n\n            self.write(stop_commands)\n            self.initialized = False\n            return True\n        except Exception as e:\n            print(f"Error during shutdown: {e}")\n            return False\n\n    def get_status(self) -> Dict[str, Any]:\n        """Get current status of the joint hardware interface"""\n        return {\n            \'initialized\': self.initialized,\n            \'joint_names\': self.joint_names,\n            \'last_read_time\': self.last_read_time,\n            \'last_write_time\': self.last_write_time\n        }\n\nclass MockJointHardwareInterface(JointHardwareInterface):\n    """Mock implementation of joint hardware interface for testing"""\n\n    def __init__(self, joint_names: list):\n        super().__init__(joint_names)\n        self.joint_states = {f\'{name}/position\': 0.0 for name in joint_names}\n        self.joint_states.update({f\'{name}/velocity\': 0.0 for name in joint_names})\n        self.joint_states.update({f\'{name}/effort\': 0.0 for name in joint_names})\n\n    def _initialize_hardware(self):\n        """Initialize mock hardware state"""\n        for joint_name in self.joint_names:\n            self.joint_states[f\'{joint_name}/position\'] = 0.0\n            self.joint_states[f\'{joint_name}/velocity\'] = 0.0\n            self.joint_states[f\'{joint_name}/effort\'] = 0.0\n\n    def read(self) -> Dict[str, Any]:\n        """Read mock joint states"""\n        if not self.initialized:\n            raise RuntimeError("Hardware not initialized")\n\n        self.last_read_time = time.time()\n        return self.joint_states.copy()\n\n    def write(self, commands: Dict[str, Any]) -> bool:\n        """Write to mock joint hardware"""\n        if not self.initialized:\n            raise RuntimeError("Hardware not initialized")\n\n        self.last_write_time = time.time()\n\n        # Update mock states based on commands\n        for joint_name in self.joint_names:\n            pos_cmd = commands.get(f\'{joint_name}/position\')\n            vel_cmd = commands.get(f\'{joint_name}/velocity\')\n            eff_cmd = commands.get(f\'{joint_name}/effort\')\n\n            if pos_cmd is not None:\n                self.joint_states[f\'{joint_name}/position\'] = pos_cmd\n            if vel_cmd is not None:\n                self.joint_states[f\'{joint_name}/velocity\'] = vel_cmd\n            if eff_cmd is not None:\n                self.joint_states[f\'{joint_name}/effort\'] = eff_cmd\n\n        return True\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create the ROS 2 hardware interface node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_control/robot_control/ros_hardware_interface.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\nfrom .hardware_interface import MockJointHardwareInterface\nimport traceback\n\nclass RosHardwareInterface(Node):\n    def __init__(self):\n        super().__init__('ros_hardware_interface')\n\n        # Declare parameters\n        self.declare_parameter('joint_names', ['joint1', 'joint2', 'joint3'])\n        self.declare_parameter('publish_rate', 50.0)  # Hz\n        self.declare_parameter('use_mock_hardware', True)\n\n        # Get parameters\n        joint_names = self.get_parameter('joint_names').value\n        publish_rate = self.get_parameter('publish_rate').value\n        use_mock_hardware = self.get_parameter('use_mock_hardware').value\n\n        # Create hardware interface\n        if use_mock_hardware:\n            self.hw_interface = MockJointHardwareInterface(joint_names)\n        else:\n            # In real implementation, create actual hardware interface\n            self.get_logger().warn('Real hardware interface not implemented, using mock')\n            self.hw_interface = MockJointHardwareInterface(joint_names)\n\n        # Initialize hardware\n        if not self.hw_interface.initialize():\n            self.get_logger().error('Failed to initialize hardware interface')\n            return\n\n        # Create publishers and subscribers\n        self.joint_state_pub = self.create_publisher(JointState, 'joint_states', 10)\n\n        # Create timer for reading hardware and publishing states\n        self.timer = self.create_timer(1.0/publish_rate, self.read_and_publish)\n\n        self.get_logger().info(\n            f'ROS Hardware Interface initialized:\\n'\n            f'  Joints: {joint_names}\\n'\n            f'  Rate: {publish_rate} Hz\\n'\n            f'  Mock: {use_mock_hardware}'\n        )\n\n    def read_and_publish(self):\n        \"\"\"Read from hardware and publish joint states\"\"\"\n        try:\n            # Read current states from hardware\n            states = self.hw_interface.read()\n\n            # Create joint state message\n            msg = JointState()\n            msg.header = Header()\n            msg.header.stamp = self.get_clock().now().to_msg()\n            msg.header.frame_id = 'base_link'\n\n            # Extract positions, velocities, and efforts\n            positions = []\n            velocities = []\n            efforts = []\n\n            # Get joint names from the state dictionary\n            joint_names = []\n            for key in states.keys():\n                if '/position' in key:\n                    joint_name = key.replace('/position', '')\n                    joint_names.append(joint_name)\n                    positions.append(states.get(f'{joint_name}/position', 0.0))\n                    velocities.append(states.get(f'{joint_name}/velocity', 0.0))\n                    efforts.append(states.get(f'{joint_name}/effort', 0.0))\n\n            msg.name = joint_names\n            msg.position = positions\n            msg.velocity = velocities\n            msg.effort = efforts\n\n            # Publish the joint state\n            self.joint_state_pub.publish(msg)\n\n        except Exception as e:\n            self.get_logger().error(f'Error in read_and_publish: {e}')\n            self.get_logger().debug(traceback.format_exc())\n\n    def destroy_node(self):\n        \"\"\"Override to ensure hardware shutdown\"\"\"\n        try:\n            if hasattr(self, 'hw_interface'):\n                self.hw_interface.shutdown()\n        except Exception as e:\n            self.get_logger().error(f'Error during hardware shutdown: {e}')\n        finally:\n            super().destroy_node()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    ros_hw_interface = RosHardwareInterface()\n\n    try:\n        rclpy.spin(ros_hw_interface)\n    except KeyboardInterrupt:\n        ros_hw_interface.get_logger().info('Shutting down ROS Hardware Interface...')\n    finally:\n        ros_hw_interface.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create a launch file for the hardware interface:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_control/launch/hardware_interface.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Declare launch arguments\n    joint_names = LaunchConfiguration('joint_names')\n    publish_rate = LaunchConfiguration('publish_rate')\n    use_mock_hardware = LaunchConfiguration('use_mock_hardware')\n\n    joint_names_arg = DeclareLaunchArgument(\n        'joint_names',\n        default_value=\"['joint1', 'joint2', 'joint3']\",\n        description='List of joint names for the robot'\n    )\n\n    publish_rate_arg = DeclareLaunchArgument(\n        'publish_rate',\n        default_value='50.0',\n        description='Publish rate for joint states (Hz)'\n    )\n\n    use_mock_hardware_arg = DeclareLaunchArgument(\n        'use_mock_hardware',\n        default_value='true',\n        description='Use mock hardware interface instead of real hardware'\n    )\n\n    # Create hardware interface node\n    hw_interface_node = Node(\n        package='robot_control',\n        executable='ros_hardware_interface',\n        name='ros_hardware_interface',\n        parameters=[\n            {'joint_names': joint_names},\n            {'publish_rate': publish_rate},\n            {'use_mock_hardware': use_mock_hardware}\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        joint_names_arg,\n        publish_rate_arg,\n        use_mock_hardware_arg,\n        hw_interface_node\n    ])\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Update the setup.py to include the new modules:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Add to ~/ros2_ws/src/robot_control/setup.py\nentry_points={\n    'console_scripts': [\n        'ros_hardware_interface = robot_control.ros_hardware_interface:main',\n    ],\n},\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Build and test the hardware abstraction layer:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select robot_control\nsource install/setup.bash\n\n# Run the hardware interface\nros2 launch robot_control hardware_interface.launch.py\n\n# In another terminal, check the joint states\nros2 topic echo /joint_states\n"})}),"\n"]}),"\n"]}),(0,s.jsx)(n.h3,{id:"expected-outcome-1",children:"Expected Outcome"}),(0,s.jsx)(n.p,{children:"A comprehensive hardware abstraction layer that separates hardware-specific code from ROS 2 interface code, allowing for easy switching between real hardware and simulation."}),(0,s.jsx)(n.h3,{id:"troubleshooting-tips-1",children:"Troubleshooting Tips"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ensure proper exception handling in hardware interface methods"}),"\n",(0,s.jsx)(n.li,{children:"Verify that parameters are correctly passed between launch files and nodes"}),"\n",(0,s.jsx)(n.li,{children:"Check that hardware initialization and shutdown are properly handled"}),"\n"]})]}),"\n",(0,s.jsxs)(i.A,{title:"Lab 6.3: System Monitoring and Logging Configuration",time:"60 min",difficulty:"Medium",children:[(0,s.jsx)(n.h3,{id:"objective-2",children:"Objective"}),(0,s.jsx)(n.p,{children:"Set up comprehensive system monitoring and logging for a robotic application with diagnostic reporting."}),(0,s.jsx)(n.h3,{id:"steps-2",children:"Steps"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create a comprehensive diagnostic monitor:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_monitoring/robot_monitoring/diagnostic_monitor.py\nimport rclpy\nfrom rclpy.node import Node\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue\nfrom std_msgs.msg import Header\nfrom sensor_msgs.msg import Temperature, BatteryState\nimport psutil\nimport socket\nimport time\nimport os\n\nclass DiagnosticMonitor(Node):\n    def __init__(self):\n        super().__init__('diagnostic_monitor')\n\n        # Create publisher for diagnostics\n        self.diag_pub = self.create_publisher(DiagnosticArray, '/diagnostics', 10)\n\n        # Create subscribers for robot-specific data\n        self.temp_sub = self.create_subscription(\n            Temperature,\n            'temperature',\n            self.temp_callback,\n            10\n        )\n        self.battery_sub = self.create_subscription(\n            BatteryState,\n            'battery_state',\n            self.battery_callback,\n            10\n        )\n\n        # Initialize variables to store sensor data\n        self.last_temp = None\n        self.last_battery = None\n\n        # Create timer for publishing diagnostics\n        self.timer = self.create_timer(1.0, self.publish_diagnostics)\n\n        self.get_logger().info('Diagnostic Monitor initialized')\n\n    def temp_callback(self, msg):\n        \"\"\"Handle temperature message\"\"\"\n        self.last_temp = msg.temperature\n\n    def battery_callback(self, msg):\n        \"\"\"Handle battery state message\"\"\"\n        self.last_battery = {\n            'voltage': msg.voltage,\n            'temperature': msg.temperature,\n            'current': msg.current,\n            'charge': msg.charge,\n            'capacity': msg.capacity,\n            'design_capacity': msg.design_capacity,\n            'percentage': msg.percentage,\n            'power_supply_status': msg.power_supply_status,\n            'power_supply_health': msg.power_supply_health,\n            'power_supply_technology': msg.power_supply_technology\n        }\n\n    def publish_diagnostics(self):\n        \"\"\"Publish comprehensive diagnostic information\"\"\"\n        diag_array = DiagnosticArray()\n        diag_array.header = Header()\n        diag_array.header.stamp = self.get_clock().now().to_msg()\n\n        # System status diagnostic\n        system_diag = self.get_system_status()\n        diag_array.status.append(system_diag)\n\n        # Robot-specific diagnostics\n        if self.last_temp is not None:\n            temp_diag = self.get_temperature_status()\n            diag_array.status.append(temp_diag)\n\n        if self.last_battery is not None:\n            battery_diag = self.get_battery_status()\n            diag_array.status.append(battery_diag)\n\n        # ROS node status\n        node_diag = self.get_node_status()\n        diag_array.status.append(node_diag)\n\n        # Publish diagnostics\n        self.diag_pub.publish(diag_array)\n\n    def get_system_status(self):\n        \"\"\"Get system-level diagnostic information\"\"\"\n        diag = DiagnosticStatus()\n        diag.name = f'{socket.gethostname()}_system_status'\n        diag.hardware_id = socket.gethostname()\n\n        # CPU usage\n        cpu_percent = psutil.cpu_percent()\n        diag.values.append(KeyValue(key='CPU Usage (%)', value=f'{cpu_percent:.2f}'))\n\n        # Memory usage\n        memory = psutil.virtual_memory()\n        diag.values.append(KeyValue(key='Memory Usage (%)', value=f'{memory.percent:.2f}'))\n        diag.values.append(KeyValue(key='Memory Available (MB)', value=f'{memory.available / 1024 / 1024:.2f}'))\n\n        # Disk usage\n        disk = psutil.disk_usage('/')\n        diag.values.append(KeyValue(key='Disk Usage (%)', value=f'{disk.percent:.2f}'))\n\n        # Process count\n        diag.values.append(KeyValue(key='Process Count', value=str(len(psutil.pids()))))\n\n        # Uptime\n        boot_time = psutil.boot_time()\n        uptime = time.time() - boot_time\n        diag.values.append(KeyValue(key='Uptime (s)', value=f'{uptime:.2f}'))\n\n        # Determine overall status\n        if cpu_percent > 90 or memory.percent > 90:\n            diag.level = DiagnosticStatus.ERROR\n            diag.message = 'High resource usage detected'\n        elif cpu_percent > 70 or memory.percent > 70:\n            diag.level = DiagnosticStatus.WARN\n            diag.message = 'Moderate resource usage'\n        else:\n            diag.level = DiagnosticStatus.OK\n            diag.message = 'System operating normally'\n\n        return diag\n\n    def get_temperature_status(self):\n        \"\"\"Get temperature sensor diagnostic information\"\"\"\n        diag = DiagnosticStatus()\n        diag.name = 'Temperature Sensor Status'\n        diag.hardware_id = 'temperature_sensor'\n\n        diag.values.append(KeyValue(key='Temperature (\xb0C)', value=f'{self.last_temp:.2f}'))\n\n        # Check temperature range\n        if self.last_temp > 80:\n            diag.level = DiagnosticStatus.ERROR\n            diag.message = 'Temperature critically high'\n        elif self.last_temp > 60:\n            diag.level = DiagnosticStatus.WARN\n            diag.message = 'Temperature elevated'\n        elif self.last_temp < 0:\n            diag.level = DiagnosticStatus.WARN\n            diag.message = 'Temperature below normal'\n        else:\n            diag.level = DiagnosticStatus.OK\n            diag.message = 'Temperature normal'\n\n        return diag\n\n    def get_battery_status(self):\n        \"\"\"Get battery diagnostic information\"\"\"\n        diag = DiagnosticStatus()\n        diag.name = 'Battery Status'\n        diag.hardware_id = 'battery'\n\n        # Add battery values\n        diag.values.append(KeyValue(key='Voltage (V)', value=f'{self.last_battery[\"voltage\"]:.2f}'))\n        diag.values.append(KeyValue(key='Temperature (\xb0C)', value=f'{self.last_battery[\"temperature\"]:.2f}'))\n        diag.values.append(KeyValue(key='Current (A)', value=f'{self.last_battery[\"current\"]:.2f}'))\n        diag.values.append(KeyValue(key='Charge (Ah)', value=f'{self.last_battery[\"charge\"]:.2f}'))\n        diag.values.append(KeyValue(key='Capacity (Ah)', value=f'{self.last_battery[\"capacity\"]:.2f}'))\n        diag.values.append(KeyValue(key='Percentage (%)', value=f'{self.last_battery[\"percentage\"] * 100:.2f}'))\n\n        # Determine status based on percentage\n        percentage = self.last_battery['percentage'] * 100\n        if percentage < 10:\n            diag.level = DiagnosticStatus.ERROR\n            diag.message = 'Battery critically low'\n        elif percentage < 20:\n            diag.level = DiagnosticStatus.WARN\n            diag.message = 'Battery low'\n        else:\n            diag.level = DiagnosticStatus.OK\n            diag.message = 'Battery normal'\n\n        return diag\n\n    def get_node_status(self):\n        \"\"\"Get ROS node diagnostic information\"\"\"\n        diag = DiagnosticStatus()\n        diag.name = 'ROS Node Status'\n        diag.hardware_id = 'ros_node'\n\n        # Get node information\n        diag.values.append(KeyValue(key='Node Name', value=self.get_name()))\n        diag.values.append(KeyValue(key='Namespace', value=self.get_namespace()))\n        diag.values.append(KeyValue(key='Publishers', value=str(len(self.get_publishers_info_by_topic('/diagnostics')))))\n        diag.values.append(KeyValue(key='Subscribers', value=str(len(self.get_subscriptions_info_by_topic('/temperature')) + len(self.get_subscriptions_info_by_topic('/battery_state')))))\n\n        diag.level = DiagnosticStatus.OK\n        diag.message = 'Node running normally'\n\n        return diag\n\ndef main(args=None):\n    rclpy.init(args=args)\n    diagnostic_monitor = DiagnosticMonitor()\n\n    try:\n        rclpy.spin(diagnostic_monitor)\n    except KeyboardInterrupt:\n        diagnostic_monitor.get_logger().info('Shutting down diagnostic monitor...')\n    finally:\n        diagnostic_monitor.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create a logging configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_monitoring/robot_monitoring/logging_config.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\nimport logging\nimport os\n\nclass LoggingConfig(Node):\n    def __init__(self):\n        super().__init__('logging_config')\n\n        # Set up custom logging\n        self.setup_custom_logging()\n\n        # Create a test publisher to demonstrate logging\n        qos_profile = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            history=HistoryPolicy.KEEP_LAST\n        )\n        self.log_pub = self.create_publisher(\n            # We'll use a simple string message for logging\n            __import__('std_msgs.msg', fromlist=['String']).String,\n            'system_log',\n            qos_profile\n        )\n\n        # Create a timer to periodically log information\n        self.timer = self.create_timer(5.0, self.log_system_info)\n\n        self.get_logger().info('Logging configuration node initialized')\n\n    def setup_custom_logging(self):\n        \"\"\"Set up custom logging configuration\"\"\"\n        # This is where you would configure custom logging\n        # For ROS 2, logging is typically handled through the built-in logging\n        # but you can still add custom handlers if needed\n\n        # Example: Log to a file as well as ROS logger\n        log_dir = os.path.join(os.path.expanduser('~'), '.ros', 'logs')\n        os.makedirs(log_dir, exist_ok=True)\n\n        log_file = os.path.join(log_dir, 'robot_system.log')\n\n        # Add file handler (this is just an example, ROS 2 handles logging differently)\n        self.get_logger().info(f'Logging to: {log_file}')\n        self.get_logger().info('Custom logging configuration applied')\n\n    def log_system_info(self):\n        \"\"\"Log system information periodically\"\"\"\n        # Log system information\n        self.get_logger().info('System status check')\n        self.get_logger().debug('Debug information for system monitoring')\n        self.get_logger().warn('This is a warning message')\n\n        # Log some performance metrics\n        import psutil\n        cpu_percent = psutil.cpu_percent()\n        memory_percent = psutil.virtual_memory().percent\n\n        self.get_logger().info(f'CPU: {cpu_percent}%, Memory: {memory_percent}%')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    logging_config = LoggingConfig()\n\n    try:\n        rclpy.spin(logging_config)\n    except KeyboardInterrupt:\n        logging_config.get_logger().info('Shutting down logging configuration node...')\n    finally:\n        logging_config.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create a launch file that combines monitoring and logging:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/robot_monitoring/launch/monitoring_system.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, TimerAction\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Declare launch arguments\n    diagnostic_period = LaunchConfiguration('diagnostic_period')\n    log_level = LaunchConfiguration('log_level')\n\n    diagnostic_period_arg = DeclareLaunchArgument(\n        'diagnostic_period',\n        default_value='1.0',\n        description='Period between diagnostic updates (seconds)'\n    )\n\n    log_level_arg = DeclareLaunchArgument(\n        'log_level',\n        default_value='INFO',\n        description='Logging level (DEBUG, INFO, WARN, ERROR)'\n    )\n\n    # Diagnostic monitor node\n    diagnostic_monitor = Node(\n        package='robot_monitoring',\n        executable='diagnostic_monitor',\n        name='diagnostic_monitor',\n        parameters=[\n            {'diagnostic_period': diagnostic_period}\n        ],\n        arguments=['--log-level', log_level],\n        output='screen'\n    )\n\n    # Logging configuration node\n    logging_config = Node(\n        package='robot_monitoring',\n        executable='logging_config',\n        name='logging_config',\n        arguments=['--log-level', log_level],\n        output='screen'\n    )\n\n    # Add a slight delay to the logging config to ensure diagnostics are available first\n    delayed_logging = TimerAction(\n        period=2.0,\n        actions=[logging_config]\n    )\n\n    return LaunchDescription([\n        diagnostic_period_arg,\n        log_level_arg,\n        diagnostic_monitor,\n        delayed_logging\n    ])\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Build and test the monitoring system:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select robot_monitoring\nsource install/setup.bash\n\n# Run the monitoring system\nros2 launch robot_monitoring monitoring_system.launch.py\n\n# In another terminal, check the diagnostics\nros2 topic echo /diagnostics\n\n# Check available diagnostic tools\nros2 run diagnostic_aggregator aggregator_node &\nros2 run rqt_robot_monitor rqt_robot_monitor\n"})}),"\n"]}),"\n"]}),(0,s.jsx)(n.h3,{id:"expected-outcome-2",children:"Expected Outcome"}),(0,s.jsx)(n.p,{children:"A comprehensive monitoring system that provides diagnostics for system resources, robot sensors, and ROS nodes with appropriate alert levels."}),(0,s.jsx)(n.h3,{id:"troubleshooting-tips-2",children:"Troubleshooting Tips"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ensure diagnostic_msgs dependency is properly declared"}),"\n",(0,s.jsx)(n.li,{children:"Check that diagnostic aggregator is running if using rqt_robot_monitor"}),"\n",(0,s.jsx)(n.li,{children:"Verify that all diagnostic status levels (OK, WARN, ERROR) are properly implemented"}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"ros-2-packagestools-used",children:"ROS 2 Packages/Tools Used"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hardware_interface"})," package: Standard interfaces for hardware abstraction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"diagnostic_updater"})," and ",(0,s.jsx)(n.code,{children:"diagnostic_common_diagnostics"}),": Diagnostic reporting tools"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ros2doctor"})," and performance analysis tools: System diagnostics and performance monitoring"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rqt_robot_monitor"})," for visualization: Real-time diagnostic monitoring interface"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"simulation-vs-real-robot-activities",children:"Simulation vs Real-Robot Activities"}),"\n",(0,s.jsx)(n.h3,{id:"simulation",children:"Simulation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Hardware-in-the-loop simulation with mock interfaces"}),"\n",(0,s.jsx)(n.li,{children:"Performance profiling in simulated environments"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"real-robot",children:"Real Robot:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Full hardware integration with real sensors and actuators"}),"\n",(0,s.jsx)(n.li,{children:"Performance optimization for real-time constraints"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"diagrams-and-figures",children:"Diagrams and Figures"}),"\n",(0,s.jsx)(n.h3,{id:"hardware-abstraction-layer-architecture",children:"Hardware Abstraction Layer Architecture"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"+-------------------+\n|   ROS 2 Nodes     |\n| (Controllers, etc)|\n+-------------------+\n         |\n         v\n+-------------------+\n|  Hardware Abstraction Layer  |\n| (JointInterface, etc)        |\n+-------------------+\n         |\n         v\n+-------------------+\n|  Real Hardware    |\n| (Drivers, etc)    |\n+-------------------+\n"})}),"\n",(0,s.jsx)(n.h3,{id:"driver-interface-design-patterns",children:"Driver Interface Design Patterns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Abstract Interface\n       |\nConcrete Mock Driver  Concrete Real Driver\n      (Testing)          (Production)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performance-profiling-workflow",children:"Performance Profiling Workflow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Application Code\n       |\n    Profiling Tools\n       |\n   Performance Data\n       |\n   Optimization\n"})}),"\n",(0,s.jsx)(n.h2,{id:"checklists",children:"Checklists"}),"\n",(0,s.jsx)(n.h3,{id:"-hardware-integration-validation-checklist",children:"\u2713 Hardware Integration Validation Checklist"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Hardware abstraction layer properly separates interface from implementation"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Error handling implemented for hardware failures"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Initialization and shutdown procedures defined"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Parameter configuration available for hardware settings"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"-performance-optimization-checklist",children:"\u2713 Performance Optimization Checklist"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","CPU and memory usage monitored and optimized"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Real-time constraints met where required"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Communication patterns optimized for performance"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Resource usage documented and validated"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"-documentation-and-testing-checklist",children:"\u2713 Documentation and Testing Checklist"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Hardware interface documentation complete"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Driver configuration parameters documented"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Error conditions and recovery procedures documented"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Integration tests covering hardware scenarios"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"glossary-terms",children:"Glossary Terms"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hardware Interface"}),": Abstraction layer between ROS nodes and physical hardware"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Driver"}),": Software component that communicates directly with hardware devices"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Abstraction Layer"}),": Software layer that hides hardware-specific details"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Diagnostics"}),": System for monitoring and reporting component health"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Profile"}),": Analysis of system resource usage and timing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitoring"}),": Continuous observation of system and hardware status"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-time Constraints"}),": Timing requirements for time-critical applications"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"cross-references",children:"Cross-References"}),"\n",(0,s.jsx)(o.A,{to:"/docs/module-1/chapter-5",title:"Chapter 5: TF and Navigation Fundamentals",type:"prerequisite",children:(0,s.jsx)(n.p,{children:"Understanding coordinate frames helps in integrating hardware with spatial systems."})}),"\n",(0,s.jsx)(o.A,{to:"/docs/module-2/chapter-1",title:"Module 2, Chapter 1: Introduction to Simulation Environments",type:"application",children:(0,s.jsx)(n.p,{children:"Apply hardware integration concepts in simulation environments for testing."})}),"\n",(0,s.jsx)(o.A,{to:"/docs/module-3/chapter-1",title:"Module 3, Chapter 1: Introduction to NVIDIA Isaac Ecosystem",type:"extension",children:(0,s.jsx)(n.p,{children:"Extend hardware integration to AI-robot systems with Isaac ROS."})}),"\n",(0,s.jsx)(n.h2,{id:"optional-advanced-section",children:"Optional Advanced Section"}),"\n",(0,s.jsx)(n.h3,{id:"real-time-constraints-and-rt-kernel-configuration",children:"Real-time Constraints and RT Kernel Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Configuring real-time kernel for time-critical robotic applications."}),"\n",(0,s.jsx)(n.h3,{id:"distributed-ros-2-systems-across-multiple-machines",children:"Distributed ROS 2 Systems Across Multiple Machines"}),"\n",(0,s.jsx)(n.p,{children:"Setting up multi-machine ROS 2 systems for distributed robotic applications."}),"\n",(0,s.jsxs)(c.A,{type:"assignment",title:"Chapter 6 Assessment: Real-world Integration and Best Practices",objectives:["Implement hardware abstraction layer for sensor/actuator integration","Create drivers following ROS 2 best practices","Set up system monitoring and diagnostic reporting","Optimize performance for real-world deployment"],rubric:[{criterion:"Hardware Abstraction",scores:[{label:"Excellent",value:"Clean abstraction with proper error handling and documentation"},{label:"Proficient",value:"Abstraction functional with minor issues"},{label:"Developing",value:"Abstraction partially implemented"},{label:"Beginning",value:"Abstraction not properly implemented"}]},{criterion:"Driver Development",scores:[{label:"Excellent",value:"Driver follows ROS 2 best practices with parameters and logging"},{label:"Proficient",value:"Driver functional with minor best practice issues"},{label:"Developing",value:"Driver partially functional"},{label:"Beginning",value:"Driver not properly implemented"}]},{criterion:"Monitoring and Diagnostics",scores:[{label:"Excellent",value:"Comprehensive monitoring with proper diagnostic levels"},{label:"Proficient",value:"Monitoring functional with minor issues"},{label:"Developing",value:"Monitoring partially implemented"},{label:"Beginning",value:"Monitoring not properly implemented"}]}],children:[(0,s.jsx)(n.h3,{id:"assignment-tasks",children:"Assignment Tasks"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Hardware Interface"}),": Design and implement a hardware abstraction layer for a robot with multiple sensors and actuators."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Driver Development"}),": Create a complete ROS 2 driver for a sensor or actuator with proper parameters, error handling, and logging."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"System Monitoring"}),": Implement a diagnostic system that monitors both system resources and robot-specific metrics."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Optimization"}),": Profile and optimize a simple control loop for real-time performance."]}),"\n"]}),"\n"]}),(0,s.jsx)(n.h3,{id:"submission-requirements",children:"Submission Requirements"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Source code for hardware abstraction layer"}),"\n",(0,s.jsx)(n.li,{children:"Complete driver implementation with launch files"}),"\n",(0,s.jsx)(n.li,{children:"Diagnostic monitoring system implementation"}),"\n",(0,s.jsx)(n.li,{children:"Performance profiling results"}),"\n",(0,s.jsx)(n.li,{children:"Documentation of hardware integration approach"}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsx)(l.A,{id:"ros2-hardware-interface-2021",authors:"Open Robotics",year:"2021",title:"ROS 2 Hardware Interface Design",source:"ROS 2 Documentation",url:"https://docs.ros.org/en/rolling/How-To-Guides/Hardware-Interface.html",children:(0,s.jsx)(n.p,{children:"The official ROS 2 documentation on hardware interface design patterns."})}),"\n",(0,s.jsx)(l.A,{id:"ros2-diagnostics-2021",authors:"Open Robotics",year:"2021",title:"ROS 2 Diagnostic System",source:"ROS 2 Documentation",url:"https://docs.ros.org/en/rolling/How-To-Guides/Using-Diagnostic-Publishers.html",children:(0,s.jsx)(n.p,{children:"The official ROS 2 documentation on diagnostic system implementation."})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_(e)}},7944(e,n,t){t.d(n,{A:()=>p});t(6540);var s=t(4164);const r="container_MRjH",a="citationContent_jj7V",i="citationText_bXIf",o="citationId_auqD",l="urlLink_ZvkM",c="description_pgVT",d="icon_HjvY";var m=t(4848);const p=({id:e,authors:n,year:t,title:p,source:u,url:g,children:_})=>(0,m.jsxs)("div",{className:(0,s.A)("citation-container",r),children:[(0,m.jsxs)("div",{className:a,children:[(0,m.jsxs)("div",{className:i,children:[(0,m.jsxs)("span",{className:o,children:["[",e,"]"]})," ",n," (",t,"). ",p,". ",u,".",g&&" Available at: ",g&&(0,m.jsx)("a",{href:g,className:l,target:"_blank",rel:"noopener noreferrer",children:g})]}),_&&(0,m.jsx)("div",{className:c,children:_})]}),(0,m.jsx)("span",{className:d,children:"\ud83d\udcda"})]})},8415(e,n,t){t.d(n,{A:()=>m});t(6540);var s=t(4164);const r="container_IT7u",a="header_CZcX",i="icon_E6M3",o="title_MIoE",l="objectivesList_NPeG",c="objectiveItem_Pr17";var d=t(4848);const m=({objectives:e,title:n="Learning Objectives"})=>(0,d.jsxs)("div",{className:(0,s.A)("learning-objectives-container",r),children:[(0,d.jsxs)("div",{className:a,children:[(0,d.jsx)("span",{className:i,children:"\ud83c\udfaf"}),(0,d.jsx)("h3",{className:o,children:n})]}),(0,d.jsx)("ul",{className:l,children:e.map((e,n)=>(0,d.jsx)("li",{className:c,children:e},n))})]})},8453(e,n,t){t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);